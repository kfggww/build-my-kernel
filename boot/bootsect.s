/*
* 从实模式进入保护模式的流程. 这些过程不可能在512B大小的代码内完成, 因此需要用
* MBR当跳板, 加载实际的内核代码, 这种情况下, MBR上的代码就相当于是bootloader了
*/


    # 准备GDT

    # 关闭中断

    # 打开A20地址线

    # 启动保护模式

    # 准备页目录表和页表

    # 启动分页

/*
* 问题:
* 1. 如果内核的尺寸大于1M怎么办? 实模式下寻址范围有限, 此时是不是就需要把设置保护模
* 式的代码单独制作成一个模块来加载, 模式转换完毕之后在去加载实际的内核.
*
* 2. 如果使用GRUB2这个bootloader, 需要做些什么? 即GRUB2和内核之间需要遵守什么样的协
* 议才能协调工作, 如何识别内核? 内核加载到哪里? 保护模式的切换谁来做? 如何向内核
* 传递一些启动参数?
*
* 3. 在multiboot2的标准中, 不同的tag的作用到底是什么? 是用来从内核向bootloader传
* 递信息还是相反的? bootloader如何知道该把内核加载到哪里? 加载之后该从哪里执行?
*
* multiboot规范主要包括三个方面, 1. OS kernel所必须包含的Multiboot Header, 用于
* bootloader识别内核映像, 其中还包含了内核向bootloader传递的信息; 2. bootloader
* 加载内核时机器所处的状态; 3. bootloader向内核传递的数据

* 现在的问题在于对编译工具链的使用, 编译选项很多, 不知道什么时候需要用什么选项.
* bootloader把内核加载到了什么地方? 加载之后GDTR的状态是什么样的?
*/
