* Bare Bones I

** 做了什么

1. 构建交叉编译工具链
2. 从汇编文件 boot.s 构建出 boot.o
3. 从 c 文件 kernel.c 构建出 kernel.o
4. 链接以上两个目标文件得到 myos.bin
5. 使用 qemu 加载

** TODO 还有什么问题? [0/3]
   
   - [ ] 交叉编译工具编译出的结果和在宿主机上有什么区别? 所谓的 TARGET 到底代表了什么?
   - [ ] Multiboot 这个标准具体包含什么内容? 目前看 Multiboot 可以看成是
     bootloader 和操作系统之间的一个接口规范, 能够让 bootloader 识别操作系统, 以
     GRUB 这个 bootloader 为例, 在其配置文件 grub.cfg 中定义了不同的内核镜像如何
     加载. 计算机启动的整体过程应该是"上电 -> BIOS/UEFI -> bootloader -> OS", 粗
     线条的看, 应该是这样的. 这次实验生成的 boot.o 需要遵循 Multiboot 的要求, 大
     小, 对齐方式, 特殊的识别标识等.
   - [ ] 需要了解多少 x86 汇编?


* 操作系统设计与实现

** chapter 1 引言

关于微内核和宏内核的比较, 宏内核在效率或者性能上可能会更好一点, 微内核只在内核中
保留必要的部分, 而将其他的功能模块作为用户进程去实现, 造成了一些额外的进程间通信
的开销,因此效率和性能会受到一定影响, 但这样的结构从理论上更适合构建分布式操作系
统, 而且不同功能模块之间的依赖比较弱, 某个功能模块的崩溃, 不会造成系统的崩溃, 所
以两种内核结构各有优势, 需要根据具体的使用场景进行取舍.

机制和策略分离. 类似于定义了接口, 可以采用不同的实现去完成接口定义的语义.

** chapter 2 进程

MINIX3 的整体系统结构分为 4 层, 从下至上依次是"内核", "驱动程序", "服务器"以及"
用户进程", 比较特别的一点是, 驱动程序运行在用户态.


* UNIX 操作系统设计

** chapter1

1. 硬件是按照核心态与用户态看待正在执行的程序的, 而实际运行的是哪个进
   程, 在硬件看来并没有区别; 操作系统按照进程的的角度看待正在执行的程
   序.
2. 内核不是与用户进程平行运行的孤立的进程集合, 而是每个用户进程的一部分.

** chapter2
** chapter3

   高速缓冲, 为了提高 IO 效率, 内核会为磁盘上的数据建立一个缓冲区, 使用哈希表和
双向循环链表组织内存中的数据块.

** chapter4

   文件系统的底层算法. 文件系统为了实现对磁盘设备的高效使用, 被设计成了一种层次
化的结构, 最底层是高速缓冲, 提供一种直接对磁盘块读写的服务;中间一层是文件系统的
基础服务, 提供存取 inode, 分配和释放 inode, 分配和释放磁盘块, 以及从路径到 inode
的解析服务, 中间层的功能依赖下层的高速缓冲;最上层是文件系统对用户暴露的系统调用
层, 提供了更高层次的抽象服务, 文件读写, 修改权限, 目录操作等相关的系统调用都是这
一层提供的.

- inode: 记录了文件的元数据, 包括文件的所有者, 所有组, 修改时间, 权限,
  文件大小, 文件数据的位置信息等等. 应该说 inode 和文件是一一对应的.
- 目录: 目录也是一种文件, 只不过文件的内容记录的是该目录下包含的文件和 inode 的对
  应关系.
- 根目录: 内核必须知道文件系统的根目录对应的 inode, 才能实现对文件系统内任意一个
  文件的访问, 因此, 根目录的 inode 必然保存在文件系统的一个特定位置, 内核在运行
  时, 根目录的 inode 会作为一个全局变量, 进程的当前工作目录信息由进程自己维护.
- 超级块: 记录了文件系统的全局信息, 包括文件系统有多大, 空闲的磁盘块列表, 空闲的
  inode 列表, ... , 超级块中的空闲磁盘块列表以及空闲 inode 列表,更像是一个在磁盘
  上的缓存, 这两个列表的数据会随着文件系统的使用动态变化, 之所以需要这样的缓存,
  是因为不必每次在分配磁盘块或者 inode 的时候都要去扫描一遍现有的状态, 需要的时
  候只要在超级块的缓存中取就好了, 如果缓存为空再去进行搜索, 并将超级块的缓存填满.
- 特殊文件: 管道, 设备文件

文件系统的存在, 屏蔽了设备的细节, 用户只要要按照一个统一的树形结构去使用设备即可,
不必关心数据是在 C 盘还是在 D 盘这种问题.

** chapter5

   主要介绍和文件系统相关的系统调用. 文件主要包括正规文件, 目录, 设备文件, 管道
   等类型. 本章讲述的系统调用有文件的打开, 关闭, 读, 写, 偏移, 目录相关, 权限相
   关, 挂载, 卸载, 复制文件描述符, 建立 link, 释放 link 等. 管道分为有名和无名,
   二者的打开方式不同, 无名管道只能在有亲缘关系的进程间使用, 并且会随着进程的声
   明周期自动销毁, 有名管道在文件系统中对应一个特殊的管道文件, 不具有亲缘关系的
   进程也可以通过有名管道进行数据传递, 总之, 管道是一种进程间通信的手段, 在读写
   管道时也涉及到同步和互斥的问题, 无名管道更像是一种共享内存的方式实现的进程间
   通信.

** chapter6

   进程的结构. 内核中存在一个数据结构用于描述进程的全部信息, 包括进程的标识信息,
   进程的处理机状态信息, 进程的控制信息. 在页式内存管理中, _每个进程都有自己的页
   表_, 页表记录了逻辑页号和物理页号之间的对应关系,系统通过页号和页内偏移可以计
   算出实际要访问的物理地址, CPU 中有一个称为快表的结构用来记录若干页表项, 在需
   要访问内存时, 首先查快表, 如果命中则可以根据命中结果访问对应的物理内存地址,
   如果未命中, 则需要先访问内存中的页表, 经过查找之后得到物理页号, 然后再访问物
   理内存, 同时把新的页表项加入到快表中, 如果快表已经满了, 则要采取某种淘汰策略.
   在实际使用中, 需要对页进行权限保护以及共享, 一个页中可能同时包含两种不同类型
   的数据, 比如同时包含代码和数据, 这时就不方便给页设置权限了, 理想的情况是每个
   页只装载同类型的数据, 这样可以有统一的权限控制,为了解决这个问题, 可以采用段页
   式存储管理, 或者在加载过程中对不足的部分填充 0, 比如页面大小式 1KB, 但某个代
   码段只有 845B 大小, 那么在加载时, 页中剩下的部分就可以填充 0, 这样每个段的起
   始字节总是在页的开始处,方便设置页的存取权限.
   

* Operating System 2
** Introduction
ASMP 和 SMP 非对称多处理机. ASMP, kernel 的代码只在一个处理机上执行, 其余的处理
机执行用户代码; SMP, kernel 的代码在每个处理机上都执行, 需要解决的问题是访问临界
区的并发.


* The Linux Documentation Project

** Ext2 文件系统
   为了能够在发生意外崩溃的情况下保证数据的完整性, Ext2 文件系统有一些冗余备份的
   机制, 比如超级块在多个 Block Group 中都存在备份, 同时每个 Block Group 中的
   Group Descripter 也存在备份, 这种方式在意外发生后, 能够在一定程度上保证数据的
   安全. 虚拟文件系统(VFS)使得 Linux 能够支持不同类型的文件系统.


* 趣谈 Linux

  - 学习 Linux 操作系统的 6 个阶段
    1. 熟练掌握命令行工具
    2. 熟练使用系统调用或者 glibc 实现想要的功能
    3. 掌握理解操作系统原理
    4. 能够阅读并理解 Linux 内核源码
    5. 在理解了内核源码的基础上, 能够对内核进行定制化的修改和扩充, 实现更高级的功能
    6. 在实践中不断理解操作系统, 更深入地学习建立在操作系统基础上的技术


* 操作系统(国防科技大学)

** chapter3 进程与处理机管理
   进程控制块(PCB), 相当于操作系统维护的一个关于进程的账本, 维护了和进程相关的必
   要数据, 包括进程的标识信息, 处理机的状态信息以及进程的控制信息.

   进程在执行的过程中, 总是在不同的进程状态之间切换, 直到进程执行完毕并退出系统.
   从操作系统的角度看到的是进程, 处理机的角度看到的是用户态和核心态之间的切换.
   当某个进程进入核心态运行时, 逻辑上依然是当前的进程在执行.

   进程的调度和进程切换. 引起进程调度的原因, 主要包括两个方面, 首先是进程"自己不
   行了", 1) 进程执行完毕退出; 2) 进程通过系统调用主动放弃处理机; 3) 进程在等待
   IO, 某个事件, 某个资源, 导致不能在继续执行下去;其次是被操作系统剥夺了, 1) 进
   程的时间片到了; 2) 某个事件发生, 导致新就绪的进程出现. 在出现这些原因时, 进程
   不是马上切换, 进程切换时需要保存被切换进程的各种信息, 用于恢复.

   进程调度算法. 为啥需要一种算法专门做调度呢, 就是为了最大化发挥硬件的性能, 同
   时保证用户的响应速度. 多级反馈队列算法, 队列从 1 级到 n 级,每个级别内部的进程
   优先级相同, 优先级递减, 时间片递增, 调度时先从优先级的队列开始, 当高优先级队
   列为空时, 再处理下一个优先级所对应的队列,如果某个进程的时间片用完而被剥夺, 那
   么他的优先级会被降低, 并挂到对应的优先级队列中去, 如果某个进程因 IO 请求而让
   出处理机, 该进程的优先级会被调高, 并挂到相应的优先级队列中去. 可以看出从 1 级
   到 n 级, 进程趋向于计算行进程, 从 n 级到 1 级, 进程趋向于 IO 型进程, 这种方式
   更倾向于 IO 型进程去调度, 当然这只是理论上的调度算法, 细节还要看具体的实现.

** chapter5 存储管理
   存储管理指的是内存资源的管理, 主要关注进程如何"放"到内存中去, 以及在内存空间
   不足时如何"替换"的问题.

   关于"放", 重点理解非连续存储管理, 进程使用逻辑上连续的地址空间, 但实际映射到
   物理内存时, 其所占用的地址可能是不连续的. 页式内存管理,将物理地址空间和逻辑地
   址空间划分成固定大小的页, 每个进程内部维护一个本进程的页表, 记录逻辑页号和物
   理页号的对应关系, 同时在 CPU 内部通过硬件缓存页表的部分页表项, 这个缓存叫做快
   表, 进程在访问内存地址时通过逻辑页号和页内偏移得到实际的物理内存地址, 同时在
   访存时, 操作系统会检查页表项每页的权限, 是否越界等,为了使得同一页的权限相同
   (读/写/执行), 逻辑页在加载到物理页时可以采取填充 0 的方式, 保证每段的起始地址
   也位于页的开始.

   关于"替换", 现代操作系统允许进程的逻辑地址空间大于实际的物理内存,进程在运行时
   只有一部分页面位于物理内存, 而其他部分则在外存中, 这时的内存相当于是逻辑地址
   空间的缓存, 通过这样的方式管理内存成为虚存管理. 为了支持虚存, 进程的页表项需
   要进行改造, 不仅是需要记录逻辑页号和物理页号的对应关系, 同时还要记录页表项对
   应的页是在内存中还是在外存中, 页的类型, 页是否被修改了, 如果页修改了, 根据页
   的类型, 可能需要回写到交换分区中去. 影响虚存效率的关键因素是产生缺页异常的频
   率,如果进程在运行时, 频繁的产生缺页异常, 那么操作系统将需要很多时间去将外存中
   的页调入内存, 同时暂时淘汰内存中的某些页, 通常的页淘汰算法是 LRU 及其改进, 这
   个目前只需要了解原理, 具体实现可以之后参考 Linux 源码. 虚存面临的另一个问题是,
   页表过大, 因为操作系统允许进程的逻辑空间现在已经比较大了, 页表中的项自然就多
   了, 在内存中找一块连续的空间保存页表就变得有些困难了, 通常的解决方案是采用多
   级页表, 但一般就两级, 因为页表级别太多会导致访问内存的效率过低.
   

* Linux 设备驱动程序

** chapter9 与硬件通信


* Unix 环境高级编程
  使用类 Unix 系统中的命令时, 各种命令完成的功能几乎都可以通过系统调用的方式实现,
  并且系统调用的名字通常和命令一样.

  使用 fork 系统调用的两种方式:
  1) 根据返回的 pid 不同, 执行不同的操作, 比如网络服务器, 可能有一个进程专门等待
     请求, 当客户端的请求到来时, 主进程可以新开一个进程去处理请求
  2) 根据返回的 pid 不同, 可以选择在子进程中执行 exec 系统调用中的一个, 用一个新
     的程序文件代替刚刚生成的进程中的程序段, 数据段, 并从新的 main 函数开始执行


* The Linux Programming Interface
  IPC(进程间通信), 是操作系统提供的一种功能, 可以分成 1) 传递数据类, 2)进程同步
  类, 3) 信号. 对于数据传递类, 包括匿名管道, FIFO, 消息队列,共享内存, socket 等;
  对于进程同步类, 主要包括信号量, 各种锁; 信号, 主要用于通知进程某些事件发生了.

  匿名管道(pipe)本质上是一块内核维护的内存空间, 只能用于有亲缘关系的进
  程之间的数据传递(目前看也不绝对, 貌似也可以用于非亲缘关系的进程). 匿
  名管道的几个特点如下:
  - 单向, 数据的传递通常要沿着一个方向
  - 容量有限, 管道的总容量有一个范围, Linux 可以调整, 使用 fcntl
  - 每次写入的数据不超过 PIPE_BUF 时, 写入的操作是原子的, 即一次写入的数据不会被
    打断, 但一次写入的数据超过 PIPE_BUF 限制时, 可能在多进程的情况下数据会交织在
    一起

  FIFO, 有名管道, 在文件系统中存在一个文件和 FIFO 对应, 可以用于非亲缘关
  系的进程传递数据. 涉及到的 syscall 主要包含:
  - 创建 FIFO: mkfifo, 指定 FIFO 的路径名, 以及 mode(权限)
  - 打开: open, 像普通文件一样打开, 指定管道名, 打开方式 oflag 可以决定 open 是否
    会阻塞
  - 读: read, 像普通文件一样读
  - 写: write, 像普通文件一样写


** chapter 4
   文件 IO 相关的系统调用. 在类 Unix 系统中, 文件包含常规文件, 设备文件,管道文件,
   终端等, 这些类型的文件可以用统一的 IO 相关系统调用进行操作. 主要包含:
   - 文件打开: open
   - 文件关闭: close
   - 文件读取: read
   - 文件写入: write
   - 文件偏移: lseek, 不是所有类型的文件都可以调用, SEEK_SET, SEEK_CUR,
     SEEK_END, 这三个参数在最后, offset 可正可负(除了 SEEK_SET 之外)
   - IO 控制: ioctl

   对于常规文件, lseek 可以导致文件中包含空洞, 空洞不占据实际的存储空间,但是对于
   读取文件的进程来说, 读取到文件空洞时, 得到的结果是 0 填充的字节序列; 空洞的存
   在使得文件的名义大小比实际的存储数据的空间大; 向空洞内写入不超过空洞大小的数
   据, 文件的名义大小不发生变化, 但实际存储空间必然是变大的.

   并非所有的文件系统都支持文件空洞, 有些文件系统会为填充 0 分配实际的存储空间.

   Linux 支持额外两个 whence 参数, 专门针对文件空洞, SEEK_DATA, SEEK_HOLE.

** chapter 5 FILE IO Further Detail
   进一步讲解了 FILE IO 相关内容. 三张表之间的关系, 如何实现的共享和保护. 其他读
   写操作, readv/writev, pread/pwrite, preadv/pwitev.
   
** chapter 6 进程
   进程在虚拟地址空间上不同 segment 的分布情况, nolocal goto, 环境变量

** chapter 7 存储空间分配
   系统调用和库函数提供的内存分配功能.

** chapter 8 用户和组
   系统中与用户和组相关的关键文件:
   - /etc/password
   - /etc/group
   - /etc/shadow

   获取上述文件中记录相关的系统调用, 每次获取一条记录/遍历全部记录

** chapter 9 进程身份标识
   - 不同类型的 ID;
   - Linux 特有的 file system UID;
   - 设置和获取不同的 ID

** chapter 10 时间和 Locale
   - 操作系统中时间的类型: 日历时间; 进程时间(用户态, 核心态, 使用 time 命令可以
     查看进程的相关时间统计)
   - 时区参数影响时间, 系统在/usr/share/zoneinfo 下的文件中保存了和时区设置相关
     的二进制文件, TZ 环境变量会影响进程对时间相关的系统调用的结果,
     /etc/localtime 文件实际上是一个指向 zoneinfo 下某个文件的符号链接
   - Locale 用于处理不同的国家或者民族信息表示方式的差别, 系统在
     /usr/share/locale 下记录了全部相关的 Locale 参数, 每个程序可以有自己的
     Locale 设置, 可以通过 locale 命令得到当前的 Locale 配置, 不同的配置项的作用
     不同, 有系统调用可以设置 Locale, 或者获取/usr/share/locale 目录下的某个选项

** chapter 11 系统的限制和选项
   1). Limits. 存在以下几种 limits:
       - 不可变的, 在<limits.h>头文件中已经定义, 运行时也不变
       - 可增加的, 标准中定义了某个 limit 的最小值, 但是具体的系统实现可能会比这
         个值大, 可以通过 sysconf, fpathconf, pathconf 获取
   2). Options. 标准定义了某些特性, 可以通过系统调用得知该系统是否支持某个标准定
   义的特性

   为了代码的可移植性, 在编写代码时需要考虑和系统相关的限制和选项.
   
** chapter 12 系统和进程的信息
   1). 进程信息. 在/proc 目录下记录每个进程自己的数据, 包括进程的状态,打开的文件
   等 2). 系统信息. 在/proc 目录下也记录和系统相关的信息, 通过 uname 系统调用可以
   得知系统的版本号, 名字等信息

** chapter 13 IO 缓冲

** chapter 14 文件系统
   1). 硬盘
   
   2). 分区

   3). ext2 文件系统的基本结构. 引导块, 超级块, inode 表, 数据区. 超级块和 inode
   表中的数据是文件系统的元数据, 每个 inode 对应一个文件, inode 中记录了文件的各
   种属性和描述信息, 以及最关键的文件数据保存位置, ext2 采用 15 个硬盘块指针记录
   文件数据, 并且分多级, 单个文件的大小足够满足目前的需求.

   4). 虚拟文件系统(VFS). Linux 支持不同类型的文件系统, VFS 可以屏蔽不同文件系统
   之间的差异, 给应用程序编程带来方便.

   5). Journaling File System. 类似数据库中的事务, 文件系统会记录其元数据的更新,
   若系统突然崩溃, 重启之后可以利用这些记录回滚未完成的操作, 从而保持文件系统的
   一致性.

   6). 文件系统的挂载. UNIX 类系统都提供统一的目录树结构, 用户不必在意
   目录下具体的设备信息. 块设备中的文件系统可以挂载到目录下, 之后用户
   直接使用目录就可以使用设备. 挂载的高级特性:
       - 一个文件系统可以挂在到多个目录下, 对其中一个目录下数据的操作会反应到其
         他的目录下
       - 一个目录可以像栈一样挂在文件系统, 后挂载的文件系统可见, 之前的被隐藏,
         当栈顶的文件系统卸载时, 其下的文件系统又变得可见

    
** chapter 15 文件属性
   文件除了本身包含的数据之外, 还有其他的描述信息, 称为文件属性. 主要包含时间戳,
   所有权, 权限, 相关的 API 和命令类似.
   
** chapter 16 文件扩展属性
   EAs. 文件的扩展属性, 实际上是文件关联的一组 name-value 对, 其中 name 的格式
   为: namespace.name, namespace 包括 user, trusted, system, security. 不同的
   namespace 作用不同, 并不是所有的扩展属性用户进程都可以访问到. 相关 API:

   设置:获取:删除:遍历:

** chapter 17 Access Control List
   1). 为什么需要 ACL? 为了更精细地控制文件的访问权限, 单纯地将全部的用户划分成
   三类, 然后分别赋予权限, 这种方式在一些情况下不能适用, 比如希望单独给某个用户
   或者某个组设置一种权限.

   2). ACL 本质上是一个列表, 列表中的每项是一个记录, 每个记录是一个三元组
   (tag_type, tag_qualifier, permission), 并且 ACL 列表的记录数量是有限制的.

   3). Default ACL. 给目录设置的 ACL 权限, 并且这个 ACL 权限是可以继承的,会沿着
   目录树向下传递.

   4). ACL API. 关键是这组 API 中涉及到的数据结构, 通过调用该组 API 可以实现不同
   数据结构之间的转换. acl_t, acl_entry_t, acl_type_t, void *(uid, gid),
   acl_permset_t.

   5). ACL_MASK 项, 权限的一个上限.

** chapter 18 Directories and Links
   1). 文件夹, 文件, inode 表之间的关系. 文件夹是也是文件, 只是文件夹中的内容是
   一个记录其下包含的文件名和 inode 号之间对应关系的列表; 文件名不保存在文件数据
   块或者 inode 中, 而是保存在文件夹的数据块中; 每个文件实际上和一个 inode 对应,
   inode 中记录了该文件的各种属性以及数据块信息;文件系统的根目录在 inode 表中的
   特殊位置.

   2). Hard Link. 文件夹中记录的表项都是 Hard Link, 多个文件名可以对应相同的
   inode, 这样就可以实现一个文件有多个名字, 其中的每个 Hard Link 并没有区别, 从实
   现的原理看, 就会明白为什么对应的系统调用叫做 link 以及 unlink 了.

   3). Symbolic Link. 符号链接或者软链接, 实际上也是一个文件, 只是文件的数据中记
   录了其链接的文件的路径. Symbolic Link 类似 C 语言的指针, 并且 Symbolic Link
   可以多重, 重数可能受到具体操作系统实现的影响.

   4). 创建目录和删除目录

   5). 遍历某个目录下的内容, opendir, readdir

   6). 遍历目录树. nftw

   7). 和进程相关的有关目录的系统调用. chroot, getcwd, chdir, 其中注意 chroot
   jail, "/.." and "/" 之间的关系.

   8). 分别解析路径和文件名. dirname, basename

** chapter 19 监听文件事件
   inotify
   
** chapter 20 信号的基本概念
   - 信号是做什么的?
   - 信号的来源
   - 如何响应信号
   - 如何临时屏蔽信号
   - 如何获取被挂起的信号
   - 如何给其他进程发送信号

**  Doom Emacs 配置
- 是什么? Doom Emacs 是一个 Emacs 的配置框架, 不仅仅是一个配置文件, 有一套自己的
  工具用于更新和诊断等, 同时 Doom Emacs 有自己的配置文件, 可以定义 Emacs 的行为,
  在.doom 目录下, 包含 config.el, init.el 等, 这里用户可以自定义, 比如配置支持的
  编程语言, 修改完配置之后需要按照文件的说明, 确定是否需要执行 doom 命令, 其中
  doom doctor 可以提供诊断信息, 帮助解决使用过程中的问题.

**  chapter 25 进程的终止
进程终止的类型:
- 异常终止: 接受到了某个信号, 然后终止运行
- 正常终止: 通过系统调用_exit 或者库函数 exit 终止运行

_exit 和 exit 的区别:
- exit 是库函数, 被调用时会检查用户注册的进程终止时的回调函数, 刷新 stdio 的
  stream 所使用的缓冲区, 最后调用_exit 系统调用结束进程的运行
- _exit 是系统调用, 并不会处理回调函数以及标准库使用的缓冲区

注册终止时的回调函数:
- atexit: 标准中定义的
- on_exit: 未在标准中定义, 但是可以给回调函数传递进程终止的状态以及 void*类型的
  参数
回调函数可以注册多个, 同一个回调函数也可以注册多次, 但在 exit 过程中, 多个回调函
数按照注册的逆序被执行; 异常终止的进程不会调用上述库函数注册的回调函数.

** chapter 26 监视子进程
等待子进程终止的系统调用:
- wait, 可以获取子进程终止时的状态以及子进程的 pid, 只要任意一个子进程终止了,
  wait 系统调用就会返回, 若没有子进程则 wait 失败, 返回-1
- waitpid, 可以等待某个特定的子进程终止
  + pid > 0, 等待进程号等于 pid 的子进程终止
  + pid = 0, 等待同一个 group id 的一个子进程终止
  + pid = -1, 等待任意子进程终止
  + pid < -1, 等待子进程 group id 等于 pid 的绝对值的子进程终止, waitpid 可以设
    置选项, 决定是否阻塞等待等.
- 特殊说明: wait/waitpid 系统调用返回的 status 虽然式 int 类型, 但只有低两个字节
  的内容真正被使用
- waitid, 类似 waitpid, 提供了更加精细的控制
- wait3, 等待任意一个子进程终止, 并且返回进程使用的资源
- wait4, 等待一个特定的子进程终止, 并且返回进程使用的资源

孤儿进程和僵尸进程:
- 父进程先终止了, 为了让其子进程仍然具有父进程, 需要让 init 进程领养已经终止的进
  程的全部子进程
- 僵尸进程. 如果在父进程调用 wait 类系统调用之前, 子进程已经终止了, 其占有的内存,
  CPU 等资源已经被内核回收,但为了保证父进程的 wait 调用不受影响, 内核仍然保留已
  经终止的进程的一些统计信息, 包括终止原因, 资源使用情况等, 在父进程调用完 wait
  之后,僵尸进程也会被清除. _问题:_ 僵尸进程占用的内核资源还会在什么时机被释放?


** chapter 27 执行新程序
 和新程序执行相关的系统调用:
 - execve
 和新程序执行相关的库函数:
 - execl
 - execle
 - execlp
 - execv
 - execvp
 - execvpe
 上述库函数中, P 代表环境变量, l 代表参数以 list 形式传递给库函数, v 代表参数以
 数组形式传递给库函数, e 代表环境标量. 上述库函数可以用来执行脚本程序, 脚本文件
 的开始需要指定解释器路径以及可选的解释器参数, 若没有指定则会使用默认的/bin/sh 作
 为解释器.


** chapter 28 进程创建和执行新程序的更多细节
 - 进程的记账信息, Process Accounting 不是标准的一部分, 但是大部分 UNIX 实现都可
   以使用该特性, Linux 可以通过编译选项决定是否打开这一特性. 进程可以使用 acct()
   系统调用决定是否开启 Process Accounting, acct()通过传入的参数确定是打开还是关
   闭.
 - 记账信息记录的内容:
   + id 信息
   + 进程使用的资源信息
   + 进程的退出状态
 - clone() 系统调用, 类似 fork 和 cfork, 区别主要在于:
   + clone 创建的子进程和父进程共享内存空间, 调用时需要指定子进程的栈地址
   + clone 创建的子进程可以和父进程共享文件描述符表, 系统信息等数据, 这些行为可
     以通过 clone 的 flag 参数指定.
   + clone 需要指定一个子进程要执行的函数.
   + fork, vfork 这样的系统调用, 可以通过 clone 加上合适的选项实现.
   + 其他: clone 提供了很多选项, 在调用时可以使用, 这些选项是为了支持标准中线程的
     概念, 并且有些选项用来支持像容器这样的技术, 目前还不必了解每一个选项的含义.
     只需要知道有这个事情即可.
   + 父进程和子进程的各种属性之间的关系, 哪些属性会在在父子进程间共享, 哪些会被
     子进程继承, 哪些会因为系统调用而发生变化?


** chapter 34 进程组, 会话和作业控制
- 关键词:
  进程组, 会话, 控制终端, 前台进程组, 后台进程组, 控制进程

- 进程组: 进程的集合, 进程组内包含若干个进程, 其中一个是进程组的 leader

- 会话: 进程组的集合, 会话中包含若干个进程组, 其中一个是会话的 leader, 会话中的若
  干个进程组中有一个前台进程组, 以及一个或多个后台进程组, 并且会话会关联一个控制
  终端, 会话的 leader 作为控制进程. 只有前台进程组内的进程才可以从控制终端内读取输
  入, 如果后台进程组的进程试图读取控制终端的输入, 则会被信号终止执行.

- 控制终端: 目前可以这样理解, 这是一种用户和系统交互的设备, 可以是一台实际的物理
  设备, 也可以是一种通过网络和系统连接的虚拟设备.

- 作业控制: 利用上述内容, 可以在 shell 中实现作业控制, 即一个登录系统的用户, 可以
  执行多个命令, 这些被执行的命令称为作业, 每个作业可以在前台运行, 也可以在后台运
  行, shell 程序提供了命令可以把一个前台作业移到后台或者相反, 前台作业可以通过终
  端接受用户的输入, 而后台作业只能向终端输出

** chapter 35 进程优先级和调度

** chapter 36 进程资源

** chapter 37 守护进程
 1. 守护进程的特点:
    - 长时间运行, 通常开机开始, 直到系统关闭
    - 后台运行, 没有控制终端
 2. 守护进程的创建:
    - fork
    - setsid
    - fork
    - chdir
    - 关闭不需要的 fd
 3. 守护进程响应信号:
    - SIGTERM: 一般用于守护进程的终止
    - SIGHUP: 一般用来控制守护进程重新读取配置文件
 4. 使用 syslog 记录守护进程的日志:
    - syslog 相关 API
    - syslog 配置文件


** chapter 38 如何写特权安全的程序

** chapter 39 权能

** chapter 40 用户登录记录
 1. 用户登录日志文件:
    - utmp, 记录目前登录到系统的用户, 当用户登录时向该文件写入一条记录, 用户退出
      时, 从该文件中删除登录记录, 命令 who 会使用该文件.
    - wtmp, 记录用户登录和退出的过程, 包括用户名, 登录的终端, 持续时间等, 命令
      last 会使用该文件.
 2. utmpx 相关 API


** chapter 41 共享库基础
1. 解决的问题: 同一份代码被不同的程序所使用, 为了节省硬盘空间和内存空间, 引入了
   共享库技术, 同时可以在共享库中保存调试信息, 这是一个副产品.

2. 静态库: UNIX 系统提供的第一种库, 类似一个目标文件的压缩包, 把公共的代码编译然
   后制作成静态库之后, 以后每个依赖库中代码的目标文件, 就不必重新编译它依赖的那
   部分代码, 只需要链接器进行链接即可, 节省了编译时间. 从目标文件创建静态库可以
   使用 ar 命令.

3. 编译时使用静态库:
   a. 直接在命令行指定静态库全名
   b. 把静态库文件放到链接器 ld 会搜索的某个标准路径中(/usr/lib), 然后使用-l 选项指
      定静态库的名字, 例如-lpthread
   c. 静态库文件不在链接器搜索的标准路径中, 可以通过-L 选项指定附加的搜索路径.

4. 静态库的问题:
   a. 浪费硬盘空间
   b. 浪费内存空间
   c. 修改比较麻烦, 如果静态库中的某个函数功能需要修改, 那么所有依赖这个函数的可
      执行文件如果想得到更新后的功能, 那么就必须要重新编译.

5. 共享库的存在就是为了解决上述问题的, 注意共享库在不同进程之间共享的时代码, 而
   不是数据, 在共享库中定义的全局变量和静态变量在每个进程中都有一份拷贝.

6. 应用程序能够使用共享库的两个条件
   a. 应用程序必须要知道自己要使用哪些共享库
   b. 在运行时, 必须要有一个机制能够在文件系统上找到依赖的共享库, 并且把共享库加
      载到内存中.



** chapter 56 socket 介绍
- 主要内容: 介绍 socket API
- Overview: 典型的 client-server 场景, socket 可以看成是一种"设备", 每个通信的进程
  都需要创建一个这种"设备"; 服务端会把自己的"socket 设备"绑定到一个大家都知道的地
  址上, 这样每个服务端就都可以和服务端通信了.

- Stream Socket:
  1. fd = socket(domain, type, protocol) domain: socket 存在于通信 domain 之中,
     domain 决定了如何标识 socket 以及 socket 通信的范围. type: 指定了 socket 的类
     型, 至少存在两种类型的 socket, 即 SOCK_STREAM 和 SOCK_DGRAM, 前者的特点是面向连
     接, 可靠, 后者的特点是无连接, 不可靠; SOCK_STREAM 类型的 socket 以字节流的形式
     传输数据, SOCK_DGRAM 以数据报的形式传输数据.
  2. bind, 把一个 socket 和一个地址绑定, 通常用于服务端, 绑定的地址是一个众所周知
     的地址, 这样方便客户端进行连接. 也可以采用一个注册中心, 注册中心的地址是所
     有客户端都事先知道的, 服务端上线时将自己的 socket 信息上传到注册中心, 这样客
     户端就可以知道目前可用的服务端了.
  3. listen, 用于服务端, 将 socket 置于 passive 状态, 即被动等待客户端连接的状态, 注
     意客户端可能在服务端刚调用完 listen 就发来请求, 这时服务端的 accept 还没有调用,
     此时的连接称为挂起的连接, 在调用 listen 时可以指定最大的挂起连接数量, 内核根
     据这个最大数量处理挂起的连接.
  4. accept, 接受客户端的请求, 并返回一个 socket 用于和客户端通信, 新返回的 socket
     可以使用 read/write 进行读写, 也可以使用 socket 专用的 API 进行读写操作.
  5. connect, 用于客户端连接服务端.
  6. close, 关闭 socket.

- Datagram Socket:
  1. socket
  2. bind
  3. sendto
  4. recvfrom

- 理解: Stream Socket 类似于打电话, 通信双方之间存在一条连接, 打电话之前需要知道
  对方的号码, 同理, 服务端需要把自己的 socket 绑定到一个客户端知道的地址上;
  Datagram Socket 类似于邮局送信, 通信的双方都有一个信箱, 客户端在请求服务端的时
  候, 必须要知道服务端的信箱地址, 所以同理, 这种情况下, 服务端还是通常还是需要把
  自己的 socket 绑定到一个众所周知的地址, 服务端在收到客户端的请求之后, 如果需要返
  回处理结果给客户端, 只要按照"信封"上的地址回信即可.



- 备注: 在 Linux 中, 上述系统调用实际上是对 socketcall 的封装, 但是在 BSD 以及其他系统
  中不是这样的.



** chapter 57 UNIX domain socket
- 主要内容: 介绍 UNIX domain socket, 用于同一个主机的进程间通信

- 在同一个主机上的进程之间通信, 使用文件系统的路径标识 socket 地址, 文件的权限可以
  限制通信双方对 socket 文件的读写权限.



** chapter 58 TCP/IP 基础
- 主要内容: 介绍计算机网络的基本概念以及 TCP/IP 的关键特性.

- internet: 泛指计算机网络的网络, internet 的目标是使得其上的主机能够通信.

- Internet: 使用 TCP/IP 协议栈的 internet. TCP/IP 起源于 BSD, 很多个实现都派生自
  BSD 的代码, 也有一些是从头实现的(包括 Linux).

- TCP/IP 协议栈结构:
  1. 分层
  2. 下层为上层提供服务
  3. 透明, 对应层之间对等通信
  4. 数据在上下层之间的流动


- 数据链路层

- 网络层:
  - IP 地址结构: 网络号, 主机号, 子网号;
  - 特殊地址: 标记网络, 标记广播, 标记本机
  - 网络层的特点: 尽力而为的传输, 不保证可靠性, 不保证接受端收到数据包的顺序. 网
    络层解决的是主机到主机之间的通信问题.

- 传输层:
  - 解决的问题: 为不同主机或者相同主机上的应用程序提供端到端的通信服务.
  - 两种重要的传输层协议:
    + UDP
      无连接, 不可靠
    + TCP 面向连接, 可靠的传输.

      TCP 提供了"确认, 重传和超时"机制, 并且具有简单的差错校验, 每次发送方发送一
      个数据包之后, 会等待接受方返回一个确认信息, 接收方接受到数据包, 首先会对数
      据容进行校验, 如果是合法的数据包, 则返回一个确认信息给发送方, 否则就丢弃该
      数据包. 发送方在等待一个超时时间之后若还没有收到确认消息就会重新发送该数据
      包.

      TCP 提供了流量控制机制, 为了使得发送速度和接收方的接收速度相匹配, 避免大量
      接收方大量丢包. TCP 两端都维护一个缓冲区, 每次接收方返回 ACK 确认消息时, 会附
      带自己当前的缓冲区剩余大小, 发送方根据这个大小采用滑动窗口算法调整自己的发
      送速度, 从而达到流量控制的目的.

      TCP 提供了拥塞控制机制, 为了使得发送速度和网络的容量相匹配, 因为如果发送发
      发送的速度过快, 导致网路上的路由器处理速度跟不上, 此时路由器只能把来不及处
      理的包丢弃, 这也会导致丢包率过大. 拥塞控制主要有两种考虑, 一是慢启动, 即刚
      开始发送时以一个较低的速度, 之后按照指数提升发送速度; 二是拥塞检测, 当发送
      速度按照指数提升时, 很快发送速度就会达到网络容量的极限, 此时根据丢包情况可
      以检测到发生了拥塞, 可以调整发送速度提升的规律, 不再按照指数增长.


** chapter 59 Internet domain socket
- 主要内容: 介绍 Internet domain socket, 这种 socket 允许不同主机上的医用程序通
  过 TCP/IP 网络进行通信

- 字节序问题: 网络上有很多异构的计算机系统, 使用的字节序不尽相同, 因此在使用网络
  进行通信时, 首先面临的就是字节序的转换问题. TCP/IP 网络使用的时"大端"序, 有些
  计算机系统或者芯片体系架构使用的时"小端"序. 地址由低到高排列, 先存数据的高位称
  为大端序, 反之称为小端序.

- 字节序转换函数:
  htons, htonl, ntohs, ntohl

- 点分 10 进制格式的 IP 地址和网络字节序的整数地址之间的转换 inet_aton,
  inet_addr, ..., inet_pton, inet_ntop, 本质上 IPv4 或者 IPv6 的地址只不过是一个 32 位
  或者 128 位长度的大整数, 以上函数可以完成这个大整数和方便理解的点分 10 进制格式的
  转换.

- DNS:
  - 本地 DNS: /etc/hosts
  - DNS 服务器: 树形结构的分布式系统, 使用缓存避免不必要的解析请求

- /etc/services: 维护了知名的服务所使用的端口和协议, 用户自己的应用不能和这些端口冲突.





** chapter 60 服务端设计
- 主要内容: 讨论使用 socket 进行服务端设计.


** chapter 61 socket 相关的高级主题
- 主要内容: socket IO 的其他特性; TCP 协议的细节; socket 的各种选项.

** chapter 62 终端 Terminals
最初的 UNIX 系统就是一个多用户多任务的系统, 为了实现多用户同时访问系统, 每个用户需
要一个"终端"设备完成输入输出, 最初的 Terminal 有串口和 UNIX 系统连接, 用阴极射线管作
为显示设备, 用 teletypewriter(电传打字机)作为输入设备. 即历史上的确存在这样一个叫
做终端的物理设备.

随着技术的发展, 原来的终端设备已经不能满足新的需求, 比如通过网络登录系统等, 这时
出现了软件形式的终端设备, 即"终端模拟器". 不管是传统的物理终端, 还是现在的终端模
拟器, 都存在一个终端驱动(Terminal Driver)和一个终端设备(Terminal Device), 对于终
端模拟器而言, 这个终端设备就是伪终端(pseudoterminal).

伪终端(pty)包含两个设备, pts(slave 端)和 ptm(master 端), 这两个设备是内核实现的,
在文件系统中可以找到对应的设备文件. pts 和 ptm 构成了一个双向传输数据的通道, 利
用 pty 可以实现远程登录.
