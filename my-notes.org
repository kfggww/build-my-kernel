* Bare Bones I

** 做了什么

1. 构建交叉编译工具链
2. 从汇编文件boot.s构建出boot.o
3. 从c文件kernel.c构建出kernel.o
4. 链接以上两个目标文件得到myos.bin
5. 使用qemu加载

** TODO 还有什么问题? [0/3]
   
   - [ ] 交叉编译工具编译出的结果和在宿主机上有什么区别? 所谓的TARGET到底代表了什么?
   - [ ] Multiboot这个标准具体包含什么内容? 目前看Multiboot可以看成是
     bootloader和操作系统之间的一个接口规范, 能够让bootloader识别操作
     系统, 以GRUB这个bootloader为例, 在其配置文件grub.cfg中定义了不同
     的内核镜像如何加载. 计算机启动的整体过程应该是"上电 -> BIOS/UEFI
     -> bootloader -> OS", 粗线条的看, 应该是这样的. 这次实验生成的
     boot.o需要遵循Multiboot的要求, 大小, 对齐方式, 特殊的识别标识等.
   - [ ] 需要了解多少x86汇编?


* 操作系统设计与实现

** chapter 1 引言

关于微内核和宏内核的比较, 宏内核在效率或者性能上可能会更好一点, 微内核
只在内核中保留必要的部分, 而将其他的功能模块作为用户进程去实现, 造成了
一些额外的进程间通信的开销,因此效率和性能会受到一定影响, 但这样的结构
从理论上更适合构建分布式操作系统, 而且不同功能模块之间的依赖比较弱, 某
个功能模块的崩溃, 不会造成系统的崩溃, 所以两种内核结构各有优势, 需要根
据具体的使用场景进行取舍.

机制和策略分离. 类似于定义了接口, 可以采用不同的实现去完成接口定义的语
义.

** chapter 2 进程

MINIX3的整体系统结构分为4层, 从下至上依次是"内核", "驱动程序", "服务器
"以及"用户进程", 比较特别的一点是, 驱动程序运行在用户态. 


* UNIX操作系统设计

** chapter1

1. 硬件是按照核心态与用户态看待正在执行的程序的, 而实际运行的是哪个进
   程, 在硬件看来并没有区别; 操作系统按照进程的的角度看待正在执行的程
   序.
2. 内核不是与用户进程平行运行的孤立的进程集合, 而是每个用户进程的一部
   分.

** chapter2
** chapter3

   高速缓冲, 为了提高IO效率, 内核会为磁盘上的数据建立一个缓冲区, 使用
哈希表和双向循环链表组织内存中的数据块.

** chapter4

   文件系统的底层算法. 文件系统为了实现对磁盘设备的高效使用, 被设计成
了一种层次化的结构, 最底层是高速缓冲, 提供一种直接对磁盘块读写的服务;
中间一层是文件系统的基础服务, 提供存取inode, 分配和释放inode, 分配和释
放磁盘块, 以及从路径到inode的解析服务, 中间层的功能依赖下层的高速缓冲;
最上层是文件系统对用户暴露的系统调用层, 提供了更高层次的抽象服务, 文件
读写, 修改权限, 目录操作等相关的系统调用都是这一层提供的.

- inode: 记录了文件的元数据, 包括文件的所有者, 所有组, 修改时间, 权限,
  文件大小, 文件数据的位置信息等等. 应该说inode和文件是一一对应的.
- 目录: 目录也是一种文件, 只不过文件的内容记录的是该目录下包含的文件和
  inode的对应关系.
- 根目录: 内核必须知道文件系统的根目录对应的inode, 才能实现对文件系统
  内任意一个文件的访问, 因此, 根目录的inode必然保存在文件系统的一个特
  定位置, 内核在运行时, 根目录的inode会作为一个全局变量, 进程的当前工
  作目录信息由进程自己维护.
- 超级块: 记录了文件系统的全局信息, 包括文件系统有多大, 空闲的磁盘块列
  表, 空闲的inode列表, ... , 超级块中的空闲磁盘块列表以及空闲inode列表,
  更像是一个在磁盘上的缓存, 这两个列表的数据会随着文件系统的使用动态变
  化, 之所以需要这样的缓存, 是因为不必每次在分配磁盘块或者inode的时候
  都要去扫描一遍现有的状态, 需要的时候只要在超级块的缓存中取就好了, 如
  果缓存为空再去进行搜索, 并将超级块的缓存填满.
- 特殊文件: 管道, 设备文件

文件系统的存在, 屏蔽了设备的细节, 用户只要要按照一个统一的树形结构去使
用设备即可, 不必关心数据是在C盘还是在D盘这种问题.

** chapter5

   主要介绍和文件系统相关的系统调用. 文件主要包括正规文件, 目录, 设备
   文件, 管道等类型. 本章讲述的系统调用有文件的打开, 关闭, 读, 写, 偏
   移, 目录相关, 权限相关, 挂载, 卸载, 复制文件描述符, 建立link, 释放
   link等. 管道分为有名和无名, 二者的打开方式不同, 无名管道只能在有亲
   缘关系的进程间使用, 并且会随着进程的声明周期自动销毁, 有名管道在文
   件系统中对应一个特殊的管道文件, 不具有亲缘关系的进程也可以通过有名
   管道进行数据传递, 总之, 管道是一种进程间通信的手段, 在读写管道时也
   涉及到同步和互斥的问题, 无名管道更像是一种共享内存的方式实现的进程
   间通信.

** chapter6

   进程的结构. 内核中存在一个数据结构用于描述进程的全部信息, 包括进程
   的标识信息, 进程的处理机状态信息, 进程的控制信息. 在页式内存管理中,
   _每个进程都有自己的页表_, 页表记录了逻辑页号和物理页号之间的对应关系,
   系统通过页号和页内偏移可以计算出实际要访问的物理地址, CPU中有一个称
   为快表的结构用来记录若干页表项, 在需要访问内存时, 首先查快表, 如果
   命中则可以根据命中结果访问对应的物理内存地址, 如果未命中, 则需要先
   访问内存中的页表, 经过查找之后得到物理页号, 然后再访问物理内存, 同
   时把新的页表项加入到快表中, 如果快表已经满了, 则要采取某种淘汰策略.
   在实际使用中, 需要对页进行权限保护以及共享, 一个页中可能同时包含两
   种不同类型的数据, 比如同时包含代码和数据, 这时就不方便给页设置权限
   了, 理想的情况是每个页只装载同类型的数据, 这样可以有统一的权限控制,
   为了解决这个问题, 可以采用段页式存储管理, 或者在加载过程中对不足的
   部分填充0, 比如页面大小式1KB, 但某个代码段只有845B大小, 那么在加载
   时, 页中剩下的部分就可以填充0, 这样每个段的起始字节总是在页的开始处,
   方便设置页的存取权限.
   

* Operating System 2
** Introduction
ASMP和SMP非对称多处理机. ASMP, kernel的代码只在一个处理机上执行, 其余
的处理机执行用户代码; SMP, kernel的代码在每个处理机上都执行, 需要解决
的问题是访问临界区的并发.


* The Linux Documentation Project

** Ext2文件系统
   为了能够在发生意外崩溃的情况下保证数据的完整性, Ext2文件系统有一些
   冗余备份的机制, 比如超级块在多个Block Group中都存在备份, 同时每个
   Block Group中的Group Descripter也存在备份, 这种方式在意外发生后, 能
   够在一定程度上保证数据的安全.
   虚拟文件系统(VFS)使得Linux能够支持不同类型的文件系统.


* 趣谈Linux

  - 学习Linux操作系统的6个阶段
    1. 熟练掌握命令行工具
    2. 熟练使用系统调用或者glibc实现想要的功能
    3. 掌握理解操作系统原理
    4. 能够阅读并理解Linux内核源码
    5. 在理解了内核源码的基础上, 能够对内核进行定制化的修改和扩充, 实现更高级的功能
    6. 在实践中不断理解操作系统, 更深入地学习建立在操作系统基础上的技术


* 操作系统(国防科技大学)

** chapter3 进程与处理机管理
   进程控制块(PCB), 相当于操作系统维护的一个关于进程的账本, 维护了和进
   程相关的必要数据, 包括进程的标识信息, 处理机的状态信息以及进程的控
   制信息.

   进程在执行的过程中, 总是在不同的进程状态之间切换, 直到进程执行完毕
   并退出系统. 从操作系统的角度看到的是进程, 处理机的角度看到的是用户
   态和核心态之间的切换. 当某个进程进入核心态运行时, 逻辑上依然是当前
   的进程在执行.

   进程的调度和进程切换. 引起进程调度的原因, 主要包括两个方面, 首先是
   进程"自己不行了", 1) 进程执行完毕退出; 2) 进程通过系统调用主动放弃
   处理机; 3) 进程在等待IO, 某个事件, 某个资源, 导致不能在继续执行下去;
   其次是被操作系统剥夺了, 1) 进程的时间片到了; 2) 某个事件发生, 导致
   新就绪的进程出现. 在出现这些原因时, 进程不是马上切换, 进程切换时需
   要保存被切换进程的各种信息, 用于恢复.

   进程调度算法. 为啥需要一种算法专门做调度呢, 就是为了最大化发挥硬件
   的性能, 同时保证用户的响应速度. 多级反馈队列算法, 队列从1级到n级,每
   个级别内部的进程优先级相同, 优先级递减, 时间片递增, 调度时先从优先
   级的队列开始, 当高优先级队列为空时, 再处理下一个优先级所对应的队列,
   如果某个进程的时间片用完而被剥夺, 那么他的优先级会被降低, 并挂到对
   应的优先级队列中去, 如果某个进程因IO请求而让出处理机, 该进程的优先
   级会被调高, 并挂到相应的优先级队列中去. 可以看出从1级到n级, 进程趋
   向于计算行进程, 从n级到1级, 进程趋向于IO型进程, 这种方式更倾向于IO
   型进程去调度, 当然这只是理论上的调度算法, 细节还要看具体的实现.

** chapter5 存储管理
   存储管理指的是内存资源的管理, 主要关注进程如何"放"到内存中去, 以及
   在内存空间不足时如何"替换"的问题.

   关于"放", 重点理解非连续存储管理, 进程使用逻辑上连续的地址空间, 但
   实际映射到物理内存时, 其所占用的地址可能是不连续的. 页式内存管理,将
   物理地址空间和逻辑地址空间划分成固定大小的页, 每个进程内部维护一个
   本进程的页表, 记录逻辑页号和物理页号的对应关系, 同时在CPU内部通过硬
   件缓存页表的部分页表项, 这个缓存叫做快表, 进程在访问内存地址时通过
   逻辑页号和页内偏移得到实际的物理内存地址, 同时在访存时, 操作系统会
   检查页表项每页的权限, 是否越界等,为了使得同一页的权限相同(读/写/执
   行), 逻辑页在加载到物理页时可以采取填充0的方式, 保证每段的起始地址
   也位于页的开始.

   关于"替换", 现代操作系统允许进程的逻辑地址空间大于实际的物理内存,
   进程在运行时只有一部分页面位于物理内存, 而其他部分则在外存中, 这时
   的内存相当于是逻辑地址空间的缓存, 通过这样的方式管理内存成为虚存管
   理. 为了支持虚存, 进程的页表项需要进行改造, 不仅是需要记录逻辑页号
   和物理页号的对应关系, 同时还要记录页表项对应的页是在内存中还是在外
   存中, 页的类型, 页是否被修改了, 如果页修改了, 根据页的类型, 可能需
   要回写到交换分区中去. 影响虚存效率的关键因素是产生缺页异常的频率,
   如果进程在运行时, 频繁的产生缺页异常, 那么操作系统将需要很多时间去
   将外存中的页调入内存, 同时暂时淘汰内存中的某些页, 通常的页淘汰算法
   是LRU及其改进, 这个目前只需要了解原理, 具体实现可以之后参考Linux源
   码. 虚存面临的另一个问题是, 页表过大, 因为操作系统允许进程的逻辑空
   间现在已经比较大了, 页表中的项自然就多了, 在内存中找一块连续的空间
   保存页表就变得有些困难了, 通常的解决方案是采用多级页表, 但一般就两
   级, 因为页表级别太多会导致访问内存的效率过低.
   

* Linux设备驱动程序

** chapter9 与硬件通信


* Unix环境高级编程
  使用类Unix系统中的命令时, 各种命令完成的功能几乎都可以通过系统调用的
  方式实现, 并且系统调用的名字通常和命令一样.

  使用fork系统调用的两种方式:
  1) 根据返回的pid不同, 执行不同的操作, 比如网络服务器, 可能有一个进程
     专门等待请求, 当客户端的请求到来时, 主进程可以新开一个进程去处理
     请求
  2) 根据返回的pid不同, 可以选择在子进程中执行exec系统调用中的一个, 用
     一个新的程序文件代替刚刚生成的进程中的程序段, 数据段, 并从新的
     main函数开始执行


* The Linux Programming Interface
  IPC(进程间通信), 是操作系统提供的一种功能, 可以分成1) 传递数据类, 2)
  进程同步类, 3) 信号. 对于数据传递类, 包括匿名管道, FIFO, 消息队列,
  共享内存, socket等; 对于进程同步类, 主要包括信号量, 各种锁; 信号, 主
  要用于通知进程某些事件发生了.

  匿名管道(pipe)本质上是一块内核维护的内存空间, 只能用于有亲缘关系的进
  程之间的数据传递(目前看也不绝对, 貌似也可以用于非亲缘关系的进程). 匿
  名管道的几个特点如下:
  - 单向, 数据的传递通常要沿着一个方向
  - 容量有限, 管道的总容量有一个范围, Linux可以调整, 使用fcntl
  - 每次写入的数据不超过PIPE_BUF时, 写入的操作是原子的, 即一次写入的数
    据不会被打断, 但一次写入的数据超过PIPE_BUF限制时, 可能在多进程的情
    况下数据会交织在一起

  FIFO, 有名管道, 在文件系统中存在一个文件和FIFO对应, 可以用于非亲缘关
  系的进程传递数据. 涉及到的syscall主要包含:
  - 创建FIFO: mkfifo, 指定FIFO的路径名, 以及mode(权限)
  - 打开: open, 像普通文件一样打开, 指定管道名, 打开方式oflag可以决定
    open是否会阻塞
  - 读: read, 像普通文件一样读
  - 写: write, 像普通文件一样写


** chapter 4
   文件IO相关的系统调用. 在类Unix系统中, 文件包含常规文件, 设备文件,
   管道文件, 终端等, 这些类型的文件可以用统一的IO相关系统调用进行操作.
   主要包含:
   - 文件打开: open
   - 文件关闭: close
   - 文件读取: read
   - 文件写入: write
   - 文件偏移: lseek, 不是所有类型的文件都可以调用, SEEK_SET,
     SEEK_CUR, SEEK_END, 这三个参数在最后, offset可正可负(除了SEEK_SET
     之外)
   - IO控制:   ioctl

   对于常规文件, lseek可以导致文件中包含空洞, 空洞不占据实际的存储空间,
   但是对于读取文件的进程来说, 读取到文件空洞时, 得到的结果是0填充的字
   节序列; 空洞的存在使得文件的名义大小比实际的存储数据的空间大; 向空
   洞内写入不超过空洞大小的数据, 文件的名义大小不发生变化, 但实际存储
   空间必然是变大的.

   并非所有的文件系统都支持文件空洞, 有些文件系统会为填充0分配实际的存
   储空间.

   Linux支持额外两个whence参数, 专门针对文件空洞, SEEK_DATA, SEEK_HOLE.

** chapter 5 FILE IO Further Detail
   进一步讲解了FILE IO相关内容. 三张表之间的关系, 如何实现的共享和保护.
   其他读写操作, readv/writev, pread/pwrite, preadv/pwitev.
   
** chapter 6 进程
   进程在虚拟地址空间上不同segment的分布情况, nolocal goto, 环境变量

** chapter 7 存储空间分配
   系统调用和库函数提供的内存分配功能.

** chapter 8 用户和组
   系统中与用户和组相关的关键文件:
   - /etc/password
   - /etc/group
   - /etc/shadow

   获取上述文件中记录相关的系统调用, 每次获取一条记录/遍历全部记录

** chapter 9 进程身份标识
   - 不同类型的ID;
   - Linux特有的file system UID;
   - 设置和获取不同的ID

** chapter 10 时间和Locale
   - 操作系统中时间的类型: 日历时间; 进程时间(用户态, 核心态, 使用time
     命令可以查看进程的相关时间统计)
   - 时区参数影响时间, 系统在/usr/share/zoneinfo下的文件中保存了和时区
     设置相关的二进制文件, TZ环境变量会影响进程对时间相关的系统调用的
     结果, /etc/localtime文件实际上是一个指向zoneinfo下某个文件的符号
     链接
   - Locale用于处理不同的国家或者民族信息表示方式的差别, 系统在
     /usr/share/locale下记录了全部相关的Locale参数, 每个程序可以有自己
     的Locale设置, 可以通过locale命令得到当前的Locale配置, 不同的配置
     项的作用不同, 有系统调用可以设置Locale, 或者获取/usr/share/locale
     目录下的某个选项

** chapter 11 系统的限制和选项
   1). Limits. 存在以下几种limits:
       - 不可变的, 在<limits.h>头文件中已经定义, 运行时也不变
       - 可增加的, 标准中定义了某个limit的最小值, 但是具体的系统实现可
         能会比这个值大, 可以通过sysconf, fpathconf, pathconf获取
   2). Options. 标准定义了某些特性, 可以通过系统调用得知该系统是否支持
   某个标准定义的特性

   为了代码的可移植性, 在编写代码时需要考虑和系统相关的限制和选项.
   
** chapter 12 系统和进程的信息
   1). 进程信息. 在/proc目录下记录每个进程自己的数据, 包括进程的状态,
   打开的文件等
   2). 系统信息. 在/proc目录下也记录和系统相关的信息, 通过uname系统调
   用可以得知系统的版本号, 名字等信息

** chapter 13 IO缓冲

** chapter 14 文件系统
   1). 硬盘
   
   2). 分区

   3). ext2文件系统的基本结构. 引导块, 超级块, inode表, 数据区. 超级块
   和inode表中的数据是文件系统的元数据, 每个inode对应一个文件, inode中
   记录了文件的各种属性和描述信息, 以及最关键的文件数据保存位置, ext2
   采用15个硬盘块指针记录文件数据, 并且分多级, 单个文件的大小足够满足
   目前的需求.

   4). 虚拟文件系统(VFS). Linux支持不同类型的文件系统, VFS可以屏蔽不同
   文件系统之间的差异, 给应用程序编程带来方便.

   5). Journaling File System. 类似数据库中的事务, 文件系统会记录其元
   数据的更新, 若系统突然崩溃, 重启之后可以利用这些记录回滚未完成的操
   作, 从而保持文件系统的一致性.

   6). 文件系统的挂载. UNIX类系统都提供统一的目录树结构, 用户不必在意
   目录下具体的设备信息. 块设备中的文件系统可以挂载到目录下, 之后用户
   直接使用目录就可以使用设备. 挂载的高级特性:
       - 一个文件系统可以挂在到多个目录下, 对其中一个目录下数据的操作
         会反应到其他的目录下
       - 一个目录可以像栈一样挂在文件系统, 后挂载的文件系统可见, 之前
         的被隐藏, 当栈顶的文件系统卸载时, 其下的文件系统又变得可见

    
** chapter 15 文件属性
   文件除了本身包含的数据之外, 还有其他的描述信息, 称为文件属性. 主要
   包含时间戳, 所有权, 权限, 相关的API和命令类似.
   
** chapter 16 文件扩展属性
   EAs. 文件的扩展属性, 实际上是文件关联的一组name-value对, 其中name的
   格式为: namespace.name, namespace包括user, trusted, system,
   security. 不同的namespace作用不同, 并不是所有的扩展属性用户进程都可
   以访问到. 相关API:

   设置:
   获取:
   删除:
   遍历:

** chapter 17 Access Control List
   1). 为什么需要ACL? 为了更精细地控制文件的访问权限, 单纯地将全部的用
   户划分成三类, 然后分别赋予权限, 这种方式在一些情况下不能适用, 比如
   希望单独给某个用户或者某个组设置一种权限.

   2). ACL本质上是一个列表, 列表中的每项是一个记录, 每个记录是一个三元
   组(tag_type, tag_qualifier, permission), 并且ACL列表的记录数量是有
   限制的.

   3). Default ACL. 给目录设置的ACL权限, 并且这个ACL权限是可以继承的,
   会沿着目录树向下传递.

   4). ACL API. 关键是这组API中涉及到的数据结构, 通过调用该组API可以实
   现不同数据结构之间的转换. acl_t, acl_entry_t, acl_type_t, void
   *(uid, gid), acl_permset_t.

   5). ACL_MASK项, 权限的一个上限.

** chapter 18 Directories and Links
   1). 文件夹, 文件, inode表之间的关系. 文件夹是也是文件, 只是文件夹中
   的内容是一个记录其下包含的文件名和inode号之间对应关系的列表; 文件名
   不保存在文件数据块或者inode中, 而是保存在文件夹的数据块中; 每个文件
   实际上和一个inode对应, inode中记录了该文件的各种属性以及数据块信息;
   文件系统的根目录在inode表中的特殊位置.

   2). Hard Link. 文件夹中记录的表项都是Hard Link, 多个文件名可以对应
   相同的inode, 这样就可以实现一个文件有多个名字, 其中的每个Hard Link
   并没有区别, 从实现的原理看, 就会明白为什么对应的系统调用叫做link以
   及unlink了.

   3). Symbolic Link. 符号链接或者软链接, 实际上也是一个文件, 只是文件
   的数据中记录了其链接的文件的路径. Symbolic Link类似C语言的指针, 并
   且Symbolic Link可以多重, 重数可能受到具体操作系统实现的影响.

   4). 创建目录和删除目录

   5). 遍历某个目录下的内容, opendir, readdir

   6). 遍历目录树. nftw

   7). 和进程相关的有关目录的系统调用. chroot, getcwd, chdir, 其中注意
   chroot jail, "/.." and "/" 之间的关系.

   8). 分别解析路径和文件名. dirname, basename

** chapter 19 监听文件事件
   inotify
   
** chapter 20 信号的基本概念
   - 信号是做什么的?
   - 信号的来源
   - 如何响应信号
   - 如何临时屏蔽信号
   - 如何获取被挂起的信号
   - 如何给其他进程发送信号
