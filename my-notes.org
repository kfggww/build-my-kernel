* Bare Bones I

** 做了什么

1. 构建交叉编译工具链
2. 从汇编文件 boot.s 构建出 boot.o
3. 从 c 文件 kernel.c 构建出 kernel.o
4. 链接以上两个目标文件得到 myos.bin
5. 使用 qemu 加载

** TODO 还有什么问题? [0/3]
   
   - [ ] 交叉编译工具编译出的结果和在宿主机上有什么区别? 所谓的 TARGET 到底代表了什么?
   - [ ] Multiboot 这个标准具体包含什么内容? 目前看 Multiboot 可以看成是
     bootloader 和操作系统之间的一个接口规范, 能够让 bootloader 识别操作系统, 以
     GRUB 这个 bootloader 为例, 在其配置文件 grub.cfg 中定义了不同的内核镜像如何
     加载. 计算机启动的整体过程应该是"上电 -> BIOS/UEFI -> bootloader -> OS", 粗
     线条的看, 应该是这样的. 这次实验生成的 boot.o 需要遵循 Multiboot 的要求, 大
     小, 对齐方式, 特殊的识别标识等.
   - [ ] 需要了解多少 x86 汇编?


* 操作系统设计与实现

** chapter 1 引言

关于微内核和宏内核的比较, 宏内核在效率或者性能上可能会更好一点, 微内核只在内核中
保留必要的部分, 而将其他的功能模块作为用户进程去实现, 造成了一些额外的进程间通信
的开销,因此效率和性能会受到一定影响, 但这样的结构从理论上更适合构建分布式操作系
统, 而且不同功能模块之间的依赖比较弱, 某个功能模块的崩溃, 不会造成系统的崩溃, 所
以两种内核结构各有优势, 需要根据具体的使用场景进行取舍.

机制和策略分离. 类似于定义了接口, 可以采用不同的实现去完成接口定义的语义.

** chapter 2 进程

MINIX3 的整体系统结构分为 4 层, 从下至上依次是"内核", "驱动程序", "服务器"以及"
用户进程", 比较特别的一点是, 驱动程序运行在用户态.


* UNIX 操作系统设计

** chapter1

1. 硬件是按照核心态与用户态看待正在执行的程序的, 而实际运行的是哪个进
   程, 在硬件看来并没有区别; 操作系统按照进程的的角度看待正在执行的程
   序.
2. 内核不是与用户进程平行运行的孤立的进程集合, 而是每个用户进程的一部分.

** chapter2
** chapter3

   高速缓冲, 为了提高 IO 效率, 内核会为磁盘上的数据建立一个缓冲区, 使用哈希表和
双向循环链表组织内存中的数据块.

** chapter4

   文件系统的底层算法. 文件系统为了实现对磁盘设备的高效使用, 被设计成了一种层次
化的结构, 最底层是高速缓冲, 提供一种直接对磁盘块读写的服务;中间一层是文件系统的
基础服务, 提供存取 inode, 分配和释放 inode, 分配和释放磁盘块, 以及从路径到 inode
的解析服务, 中间层的功能依赖下层的高速缓冲;最上层是文件系统对用户暴露的系统调用
层, 提供了更高层次的抽象服务, 文件读写, 修改权限, 目录操作等相关的系统调用都是这
一层提供的.

- inode: 记录了文件的元数据, 包括文件的所有者, 所有组, 修改时间, 权限,
  文件大小, 文件数据的位置信息等等. 应该说 inode 和文件是一一对应的.
- 目录: 目录也是一种文件, 只不过文件的内容记录的是该目录下包含的文件和 inode 的对
  应关系.
- 根目录: 内核必须知道文件系统的根目录对应的 inode, 才能实现对文件系统内任意一个
  文件的访问, 因此, 根目录的 inode 必然保存在文件系统的一个特定位置, 内核在运行
  时, 根目录的 inode 会作为一个全局变量, 进程的当前工作目录信息由进程自己维护.
- 超级块: 记录了文件系统的全局信息, 包括文件系统有多大, 空闲的磁盘块列表, 空闲的
  inode 列表, ... , 超级块中的空闲磁盘块列表以及空闲 inode 列表,更像是一个在磁盘
  上的缓存, 这两个列表的数据会随着文件系统的使用动态变化, 之所以需要这样的缓存,
  是因为不必每次在分配磁盘块或者 inode 的时候都要去扫描一遍现有的状态, 需要的时
  候只要在超级块的缓存中取就好了, 如果缓存为空再去进行搜索, 并将超级块的缓存填满.
- 特殊文件: 管道, 设备文件

文件系统的存在, 屏蔽了设备的细节, 用户只要要按照一个统一的树形结构去使用设备即可,
不必关心数据是在 C 盘还是在 D 盘这种问题.

** chapter5

   主要介绍和文件系统相关的系统调用. 文件主要包括正规文件, 目录, 设备文件, 管道
   等类型. 本章讲述的系统调用有文件的打开, 关闭, 读, 写, 偏移, 目录相关, 权限相
   关, 挂载, 卸载, 复制文件描述符, 建立 link, 释放 link 等. 管道分为有名和无名,
   二者的打开方式不同, 无名管道只能在有亲缘关系的进程间使用, 并且会随着进程的声
   明周期自动销毁, 有名管道在文件系统中对应一个特殊的管道文件, 不具有亲缘关系的
   进程也可以通过有名管道进行数据传递, 总之, 管道是一种进程间通信的手段, 在读写
   管道时也涉及到同步和互斥的问题, 无名管道更像是一种共享内存的方式实现的进程间
   通信.

** chapter6

   进程的结构. 内核中存在一个数据结构用于描述进程的全部信息, 包括进程的标识信息,
   进程的处理机状态信息, 进程的控制信息. 在页式内存管理中, _每个进程都有自己的页
   表_, 页表记录了逻辑页号和物理页号之间的对应关系,系统通过页号和页内偏移可以计
   算出实际要访问的物理地址, CPU 中有一个称为快表的结构用来记录若干页表项, 在需
   要访问内存时, 首先查快表, 如果命中则可以根据命中结果访问对应的物理内存地址,
   如果未命中, 则需要先访问内存中的页表, 经过查找之后得到物理页号, 然后再访问物
   理内存, 同时把新的页表项加入到快表中, 如果快表已经满了, 则要采取某种淘汰策略.
   在实际使用中, 需要对页进行权限保护以及共享, 一个页中可能同时包含两种不同类型
   的数据, 比如同时包含代码和数据, 这时就不方便给页设置权限了, 理想的情况是每个
   页只装载同类型的数据, 这样可以有统一的权限控制,为了解决这个问题, 可以采用段页
   式存储管理, 或者在加载过程中对不足的部分填充 0, 比如页面大小式 1KB, 但某个代
   码段只有 845B 大小, 那么在加载时, 页中剩下的部分就可以填充 0, 这样每个段的起
   始字节总是在页的开始处,方便设置页的存取权限.
   

* Operating System 2
** Introduction
ASMP 和 SMP 非对称多处理机. ASMP, kernel 的代码只在一个处理机上执行, 其余的处理
机执行用户代码; SMP, kernel 的代码在每个处理机上都执行, 需要解决的问题是访问临界
区的并发.


* The Linux Documentation Project

** Ext2 文件系统
   为了能够在发生意外崩溃的情况下保证数据的完整性, Ext2 文件系统有一些冗余备份的
   机制, 比如超级块在多个 Block Group 中都存在备份, 同时每个 Block Group 中的
   Group Descripter 也存在备份, 这种方式在意外发生后, 能够在一定程度上保证数据的
   安全. 虚拟文件系统(VFS)使得 Linux 能够支持不同类型的文件系统.


* 趣谈 Linux

  - 学习 Linux 操作系统的 6 个阶段
    1. 熟练掌握命令行工具
    2. 熟练使用系统调用或者 glibc 实现想要的功能
    3. 掌握理解操作系统原理
    4. 能够阅读并理解 Linux 内核源码
    5. 在理解了内核源码的基础上, 能够对内核进行定制化的修改和扩充, 实现更高级的功能
    6. 在实践中不断理解操作系统, 更深入地学习建立在操作系统基础上的技术


* 操作系统(国防科技大学)

** chapter3 进程与处理机管理
   进程控制块(PCB), 相当于操作系统维护的一个关于进程的账本, 维护了和进程相关的必
   要数据, 包括进程的标识信息, 处理机的状态信息以及进程的控制信息.

   进程在执行的过程中, 总是在不同的进程状态之间切换, 直到进程执行完毕并退出系统.
   从操作系统的角度看到的是进程, 处理机的角度看到的是用户态和核心态之间的切换.
   当某个进程进入核心态运行时, 逻辑上依然是当前的进程在执行.

   进程的调度和进程切换. 引起进程调度的原因, 主要包括两个方面, 首先是进程"自己不
   行了", 1) 进程执行完毕退出; 2) 进程通过系统调用主动放弃处理机; 3) 进程在等待
   IO, 某个事件, 某个资源, 导致不能在继续执行下去;其次是被操作系统剥夺了, 1) 进
   程的时间片到了; 2) 某个事件发生, 导致新就绪的进程出现. 在出现这些原因时, 进程
   不是马上切换, 进程切换时需要保存被切换进程的各种信息, 用于恢复.

   进程调度算法. 为啥需要一种算法专门做调度呢, 就是为了最大化发挥硬件的性能, 同
   时保证用户的响应速度. 多级反馈队列算法, 队列从 1 级到 n 级,每个级别内部的进程
   优先级相同, 优先级递减, 时间片递增, 调度时先从优先级的队列开始, 当高优先级队
   列为空时, 再处理下一个优先级所对应的队列,如果某个进程的时间片用完而被剥夺, 那
   么他的优先级会被降低, 并挂到对应的优先级队列中去, 如果某个进程因 IO 请求而让
   出处理机, 该进程的优先级会被调高, 并挂到相应的优先级队列中去. 可以看出从 1 级
   到 n 级, 进程趋向于计算行进程, 从 n 级到 1 级, 进程趋向于 IO 型进程, 这种方式
   更倾向于 IO 型进程去调度, 当然这只是理论上的调度算法, 细节还要看具体的实现.

** chapter5 存储管理
   存储管理指的是内存资源的管理, 主要关注进程如何"放"到内存中去, 以及在内存空间
   不足时如何"替换"的问题.

   关于"放", 重点理解非连续存储管理, 进程使用逻辑上连续的地址空间, 但实际映射到
   物理内存时, 其所占用的地址可能是不连续的. 页式内存管理,将物理地址空间和逻辑地
   址空间划分成固定大小的页, 每个进程内部维护一个本进程的页表, 记录逻辑页号和物
   理页号的对应关系, 同时在 CPU 内部通过硬件缓存页表的部分页表项, 这个缓存叫做快
   表, 进程在访问内存地址时通过逻辑页号和页内偏移得到实际的物理内存地址, 同时在
   访存时, 操作系统会检查页表项每页的权限, 是否越界等,为了使得同一页的权限相同
   (读/写/执行), 逻辑页在加载到物理页时可以采取填充 0 的方式, 保证每段的起始地址
   也位于页的开始.

   关于"替换", 现代操作系统允许进程的逻辑地址空间大于实际的物理内存,进程在运行时
   只有一部分页面位于物理内存, 而其他部分则在外存中, 这时的内存相当于是逻辑地址
   空间的缓存, 通过这样的方式管理内存成为虚存管理. 为了支持虚存, 进程的页表项需
   要进行改造, 不仅是需要记录逻辑页号和物理页号的对应关系, 同时还要记录页表项对
   应的页是在内存中还是在外存中, 页的类型, 页是否被修改了, 如果页修改了, 根据页
   的类型, 可能需要回写到交换分区中去. 影响虚存效率的关键因素是产生缺页异常的频
   率,如果进程在运行时, 频繁的产生缺页异常, 那么操作系统将需要很多时间去将外存中
   的页调入内存, 同时暂时淘汰内存中的某些页, 通常的页淘汰算法是 LRU 及其改进, 这
   个目前只需要了解原理, 具体实现可以之后参考 Linux 源码. 虚存面临的另一个问题是,
   页表过大, 因为操作系统允许进程的逻辑空间现在已经比较大了, 页表中的项自然就多
   了, 在内存中找一块连续的空间保存页表就变得有些困难了, 通常的解决方案是采用多
   级页表, 但一般就两级, 因为页表级别太多会导致访问内存的效率过低.
   

* Linux 设备驱动程序


** chapter1 内核模块编译基本问题
1. 内核模块可以分成内部模块以及外部模块, 内部模块指位于内核源码树上的模块, 外部
   模块指其他开发者自己开发的一些模块代码, 包括一些设备驱动等.
2. 外部模块的编译是需要依赖内核的. 这里的依赖主要是依赖 kbuild, 依赖内核源码中的
   一些头文件, 依赖内核或者其他模块导出的一些符号等. 驱动的代码是运行在内核态的,
   和普通应用程序调用 syscall 不同, 普通的应用程序只需要使用和 syscall 相关的头文件,
   而驱动代码则直接使用内核中没有暴露给用户程序使用的一些头文件.
3. 问题:
   a. 从细节上理解 Kbuild 的工作原理;
   b. Modules.symvers 的作用?
   c. 内核模块为什么可以动态加载卸载? 这和共享库有什么区别? 链接的过程到底是怎么
      样的?



** chapter2 基本字符设备驱动
1. 设备驱动是怎么其作用的?
   a. 系统中的每个设备关联了一个文件系统中的文件;
   b. 设备文件中记录了设备的主设备号和次设备号, 主设备号标识驱动, 次设备号标识同
      类设备;
   c. 驱动程序注册设备到内核时指定了设备号以及和这类设备关联的一些操作, 比如读/
      写等;
   d. 通过文件系统访问设备文件就可以调用到底层的驱动代码;

** chapter9 与硬件通信


* Unix 环境高级编程
  使用类 Unix 系统中的命令时, 各种命令完成的功能几乎都可以通过系统调用的方式实现,
  并且系统调用的名字通常和命令一样.

  使用 fork 系统调用的两种方式:
  1) 根据返回的 pid 不同, 执行不同的操作, 比如网络服务器, 可能有一个进程专门等待
     请求, 当客户端的请求到来时, 主进程可以新开一个进程去处理请求
  2) 根据返回的 pid 不同, 可以选择在子进程中执行 exec 系统调用中的一个, 用一个新
     的程序文件代替刚刚生成的进程中的程序段, 数据段, 并从新的 main 函数开始执行


* The Linux Programming Interface
  IPC(进程间通信), 是操作系统提供的一种功能, 可以分成 1) 传递数据类, 2)进程同步
  类, 3) 信号. 对于数据传递类, 包括匿名管道, FIFO, 消息队列,共享内存, socket 等;
  对于进程同步类, 主要包括信号量, 各种锁; 信号, 主要用于通知进程某些事件发生了.

  匿名管道(pipe)本质上是一块内核维护的内存空间, 只能用于有亲缘关系的进
  程之间的数据传递(目前看也不绝对, 貌似也可以用于非亲缘关系的进程). 匿
  名管道的几个特点如下:
  - 单向, 数据的传递通常要沿着一个方向
  - 容量有限, 管道的总容量有一个范围, Linux 可以调整, 使用 fcntl
  - 每次写入的数据不超过 PIPE_BUF 时, 写入的操作是原子的, 即一次写入的数据不会被
    打断, 但一次写入的数据超过 PIPE_BUF 限制时, 可能在多进程的情况下数据会交织在
    一起

  FIFO, 有名管道, 在文件系统中存在一个文件和 FIFO 对应, 可以用于非亲缘关
  系的进程传递数据. 涉及到的 syscall 主要包含:
  - 创建 FIFO: mkfifo, 指定 FIFO 的路径名, 以及 mode(权限)
  - 打开: open, 像普通文件一样打开, 指定管道名, 打开方式 oflag 可以决定 open 是否
    会阻塞
  - 读: read, 像普通文件一样读
  - 写: write, 像普通文件一样写


** chapter 4
   文件 IO 相关的系统调用. 在类 Unix 系统中, 文件包含常规文件, 设备文件,管道文件,
   终端等, 这些类型的文件可以用统一的 IO 相关系统调用进行操作. 主要包含:
   - 文件打开: open
   - 文件关闭: close
   - 文件读取: read
   - 文件写入: write
   - 文件偏移: lseek, 不是所有类型的文件都可以调用, SEEK_SET, SEEK_CUR,
     SEEK_END, 这三个参数在最后, offset 可正可负(除了 SEEK_SET 之外)
   - IO 控制: ioctl

   对于常规文件, lseek 可以导致文件中包含空洞, 空洞不占据实际的存储空间,但是对于
   读取文件的进程来说, 读取到文件空洞时, 得到的结果是 0 填充的字节序列; 空洞的存
   在使得文件的名义大小比实际的存储数据的空间大; 向空洞内写入不超过空洞大小的数
   据, 文件的名义大小不发生变化, 但实际存储空间必然是变大的.

   并非所有的文件系统都支持文件空洞, 有些文件系统会为填充 0 分配实际的存储空间.

   Linux 支持额外两个 whence 参数, 专门针对文件空洞, SEEK_DATA, SEEK_HOLE.

** chapter 5 FILE IO Further Detail
   进一步讲解了 FILE IO 相关内容. 三张表之间的关系, 如何实现的共享和保护. 其他读
   写操作, readv/writev, pread/pwrite, preadv/pwitev.
   
** chapter 6 进程
   进程在虚拟地址空间上不同 segment 的分布情况, nolocal goto, 环境变量

** chapter 7 存储空间分配
   系统调用和库函数提供的内存分配功能.

** chapter 8 用户和组
   系统中与用户和组相关的关键文件:
   - /etc/password
   - /etc/group
   - /etc/shadow

   获取上述文件中记录相关的系统调用, 每次获取一条记录/遍历全部记录

** chapter 9 进程身份标识
   - 不同类型的 ID;
   - Linux 特有的 file system UID;
   - 设置和获取不同的 ID

** chapter 10 时间和 Locale
   - 操作系统中时间的类型: 日历时间; 进程时间(用户态, 核心态, 使用 time 命令可以
     查看进程的相关时间统计)
   - 时区参数影响时间, 系统在/usr/share/zoneinfo 下的文件中保存了和时区设置相关
     的二进制文件, TZ 环境变量会影响进程对时间相关的系统调用的结果,
     /etc/localtime 文件实际上是一个指向 zoneinfo 下某个文件的符号链接
   - Locale 用于处理不同的国家或者民族信息表示方式的差别, 系统在
     /usr/share/locale 下记录了全部相关的 Locale 参数, 每个程序可以有自己的
     Locale 设置, 可以通过 locale 命令得到当前的 Locale 配置, 不同的配置项的作用
     不同, 有系统调用可以设置 Locale, 或者获取/usr/share/locale 目录下的某个选项

** chapter 11 系统的限制和选项
   1). Limits. 存在以下几种 limits:
       - 不可变的, 在<limits.h>头文件中已经定义, 运行时也不变
       - 可增加的, 标准中定义了某个 limit 的最小值, 但是具体的系统实现可能会比这
         个值大, 可以通过 sysconf, fpathconf, pathconf 获取
   2). Options. 标准定义了某些特性, 可以通过系统调用得知该系统是否支持某个标准定
   义的特性

   为了代码的可移植性, 在编写代码时需要考虑和系统相关的限制和选项.
   
** chapter 12 系统和进程的信息
   1). 进程信息. 在/proc 目录下记录每个进程自己的数据, 包括进程的状态,打开的文件
   等 2). 系统信息. 在/proc 目录下也记录和系统相关的信息, 通过 uname 系统调用可以
   得知系统的版本号, 名字等信息

** chapter 13 IO 缓冲

** chapter 14 文件系统
   1). 硬盘
   
   2). 分区

   3). ext2 文件系统的基本结构. 引导块, 超级块, inode 表, 数据区. 超级块和 inode
   表中的数据是文件系统的元数据, 每个 inode 对应一个文件, inode 中记录了文件的各
   种属性和描述信息, 以及最关键的文件数据保存位置, ext2 采用 15 个硬盘块指针记录
   文件数据, 并且分多级, 单个文件的大小足够满足目前的需求.

   4). 虚拟文件系统(VFS). Linux 支持不同类型的文件系统, VFS 可以屏蔽不同文件系统
   之间的差异, 给应用程序编程带来方便.

   5). Journaling File System. 类似数据库中的事务, 文件系统会记录其元数据的更新,
   若系统突然崩溃, 重启之后可以利用这些记录回滚未完成的操作, 从而保持文件系统的
   一致性.

   6). 文件系统的挂载. UNIX 类系统都提供统一的目录树结构, 用户不必在意
   目录下具体的设备信息. 块设备中的文件系统可以挂载到目录下, 之后用户
   直接使用目录就可以使用设备. 挂载的高级特性:
       - 一个文件系统可以挂在到多个目录下, 对其中一个目录下数据的操作会反应到其
         他的目录下
       - 一个目录可以像栈一样挂在文件系统, 后挂载的文件系统可见, 之前的被隐藏,
         当栈顶的文件系统卸载时, 其下的文件系统又变得可见

    
** chapter 15 文件属性
   文件除了本身包含的数据之外, 还有其他的描述信息, 称为文件属性. 主要包含时间戳,
   所有权, 权限, 相关的 API 和命令类似.
   
** chapter 16 文件扩展属性
   EAs. 文件的扩展属性, 实际上是文件关联的一组 name-value 对, 其中 name 的格式
   为: namespace.name, namespace 包括 user, trusted, system, security. 不同的
   namespace 作用不同, 并不是所有的扩展属性用户进程都可以访问到. 相关 API:

   设置:获取:删除:遍历:

** chapter 17 Access Control List
   1). 为什么需要 ACL? 为了更精细地控制文件的访问权限, 单纯地将全部的用户划分成
   三类, 然后分别赋予权限, 这种方式在一些情况下不能适用, 比如希望单独给某个用户
   或者某个组设置一种权限.

   2). ACL 本质上是一个列表, 列表中的每项是一个记录, 每个记录是一个三元组
   (tag_type, tag_qualifier, permission), 并且 ACL 列表的记录数量是有限制的.

   3). Default ACL. 给目录设置的 ACL 权限, 并且这个 ACL 权限是可以继承的,会沿着
   目录树向下传递.

   4). ACL API. 关键是这组 API 中涉及到的数据结构, 通过调用该组 API 可以实现不同
   数据结构之间的转换. acl_t, acl_entry_t, acl_type_t, void *(uid, gid),
   acl_permset_t.

   5). ACL_MASK 项, 权限的一个上限.

** chapter 18 Directories and Links
   1). 文件夹, 文件, inode 表之间的关系. 文件夹是也是文件, 只是文件夹中的内容是
   一个记录其下包含的文件名和 inode 号之间对应关系的列表; 文件名不保存在文件数据
   块或者 inode 中, 而是保存在文件夹的数据块中; 每个文件实际上和一个 inode 对应,
   inode 中记录了该文件的各种属性以及数据块信息;文件系统的根目录在 inode 表中的
   特殊位置.

   2). Hard Link. 文件夹中记录的表项都是 Hard Link, 多个文件名可以对应相同的
   inode, 这样就可以实现一个文件有多个名字, 其中的每个 Hard Link 并没有区别, 从实
   现的原理看, 就会明白为什么对应的系统调用叫做 link 以及 unlink 了.

   3). Symbolic Link. 符号链接或者软链接, 实际上也是一个文件, 只是文件的数据中记
   录了其链接的文件的路径. Symbolic Link 类似 C 语言的指针, 并且 Symbolic Link
   可以多重, 重数可能受到具体操作系统实现的影响.

   4). 创建目录和删除目录

   5). 遍历某个目录下的内容, opendir, readdir

   6). 遍历目录树. nftw

   7). 和进程相关的有关目录的系统调用. chroot, getcwd, chdir, 其中注意 chroot
   jail, "/.." and "/" 之间的关系.

   8). 分别解析路径和文件名. dirname, basename

** chapter 19 监听文件事件
   inotify
   
** chapter 20 信号的基本概念
   - 信号是做什么的?
   - 信号的来源
   - 如何响应信号
   - 如何临时屏蔽信号
   - 如何获取被挂起的信号
   - 如何给其他进程发送信号

**  Doom Emacs 配置
- 是什么? Doom Emacs 是一个 Emacs 的配置框架, 不仅仅是一个配置文件, 有一套自己的
  工具用于更新和诊断等, 同时 Doom Emacs 有自己的配置文件, 可以定义 Emacs 的行为,
  在.doom 目录下, 包含 config.el, init.el 等, 这里用户可以自定义, 比如配置支持的
  编程语言, 修改完配置之后需要按照文件的说明, 确定是否需要执行 doom 命令, 其中
  doom doctor 可以提供诊断信息, 帮助解决使用过程中的问题.

**  chapter 25 进程的终止
进程终止的类型:
- 异常终止: 接受到了某个信号, 然后终止运行
- 正常终止: 通过系统调用_exit 或者库函数 exit 终止运行

_exit 和 exit 的区别:
- exit 是库函数, 被调用时会检查用户注册的进程终止时的回调函数, 刷新 stdio 的
  stream 所使用的缓冲区, 最后调用_exit 系统调用结束进程的运行
- _exit 是系统调用, 并不会处理回调函数以及标准库使用的缓冲区

注册终止时的回调函数:
- atexit: 标准中定义的
- on_exit: 未在标准中定义, 但是可以给回调函数传递进程终止的状态以及 void*类型的
  参数
回调函数可以注册多个, 同一个回调函数也可以注册多次, 但在 exit 过程中, 多个回调函
数按照注册的逆序被执行; 异常终止的进程不会调用上述库函数注册的回调函数.

** chapter 26 监视子进程
等待子进程终止的系统调用:
- wait, 可以获取子进程终止时的状态以及子进程的 pid, 只要任意一个子进程终止了,
  wait 系统调用就会返回, 若没有子进程则 wait 失败, 返回-1
- waitpid, 可以等待某个特定的子进程终止
  + pid > 0, 等待进程号等于 pid 的子进程终止
  + pid = 0, 等待同一个 group id 的一个子进程终止
  + pid = -1, 等待任意子进程终止
  + pid < -1, 等待子进程 group id 等于 pid 的绝对值的子进程终止, waitpid 可以设
    置选项, 决定是否阻塞等待等.
- 特殊说明: wait/waitpid 系统调用返回的 status 虽然式 int 类型, 但只有低两个字节
  的内容真正被使用
- waitid, 类似 waitpid, 提供了更加精细的控制
- wait3, 等待任意一个子进程终止, 并且返回进程使用的资源
- wait4, 等待一个特定的子进程终止, 并且返回进程使用的资源

孤儿进程和僵尸进程:
- 父进程先终止了, 为了让其子进程仍然具有父进程, 需要让 init 进程领养已经终止的进
  程的全部子进程
- 僵尸进程. 如果在父进程调用 wait 类系统调用之前, 子进程已经终止了, 其占有的内存,
  CPU 等资源已经被内核回收,但为了保证父进程的 wait 调用不受影响, 内核仍然保留已
  经终止的进程的一些统计信息, 包括终止原因, 资源使用情况等, 在父进程调用完 wait
  之后,僵尸进程也会被清除. _问题:_ 僵尸进程占用的内核资源还会在什么时机被释放?


** chapter 27 执行新程序
 和新程序执行相关的系统调用:
 - execve
 和新程序执行相关的库函数:
 - execl
 - execle
 - execlp
 - execv
 - execvp
 - execvpe
 上述库函数中, P 代表环境变量, l 代表参数以 list 形式传递给库函数, v 代表参数以
 数组形式传递给库函数, e 代表环境标量. 上述库函数可以用来执行脚本程序, 脚本文件
 的开始需要指定解释器路径以及可选的解释器参数, 若没有指定则会使用默认的/bin/sh 作
 为解释器.


** chapter 28 进程创建和执行新程序的更多细节
 - 进程的记账信息, Process Accounting 不是标准的一部分, 但是大部分 UNIX 实现都可
   以使用该特性, Linux 可以通过编译选项决定是否打开这一特性. 进程可以使用 acct()
   系统调用决定是否开启 Process Accounting, acct()通过传入的参数确定是打开还是关
   闭.
 - 记账信息记录的内容:
   + id 信息
   + 进程使用的资源信息
   + 进程的退出状态
 - clone() 系统调用, 类似 fork 和 cfork, 区别主要在于:
   + clone 创建的子进程和父进程共享内存空间, 调用时需要指定子进程的栈地址
   + clone 创建的子进程可以和父进程共享文件描述符表, 系统信息等数据, 这些行为可
     以通过 clone 的 flag 参数指定.
   + clone 需要指定一个子进程要执行的函数.
   + fork, vfork 这样的系统调用, 可以通过 clone 加上合适的选项实现.
   + 其他: clone 提供了很多选项, 在调用时可以使用, 这些选项是为了支持标准中线程的
     概念, 并且有些选项用来支持像容器这样的技术, 目前还不必了解每一个选项的含义.
     只需要知道有这个事情即可.
   + 父进程和子进程的各种属性之间的关系, 哪些属性会在在父子进程间共享, 哪些会被
     子进程继承, 哪些会因为系统调用而发生变化?


** chapter 34 进程组, 会话和作业控制
- 关键词:
  进程组, 会话, 控制终端, 前台进程组, 后台进程组, 控制进程

- 进程组: 进程的集合, 进程组内包含若干个进程, 其中一个是进程组的 leader

- 会话: 进程组的集合, 会话中包含若干个进程组, 其中一个是会话的 leader, 会话中的若
  干个进程组中有一个前台进程组, 以及一个或多个后台进程组, 并且会话会关联一个控制
  终端, 会话的 leader 作为控制进程. 只有前台进程组内的进程才可以从控制终端内读取输
  入, 如果后台进程组的进程试图读取控制终端的输入, 则会被信号终止执行.

- 控制终端: 目前可以这样理解, 这是一种用户和系统交互的设备, 可以是一台实际的物理
  设备, 也可以是一种通过网络和系统连接的虚拟设备.

- 作业控制: 利用上述内容, 可以在 shell 中实现作业控制, 即一个登录系统的用户, 可以
  执行多个命令, 这些被执行的命令称为作业, 每个作业可以在前台运行, 也可以在后台运
  行, shell 程序提供了命令可以把一个前台作业移到后台或者相反, 前台作业可以通过终
  端接受用户的输入, 而后台作业只能向终端输出

** chapter 35 进程优先级和调度

** chapter 36 进程资源

** chapter 37 守护进程
 1. 守护进程的特点:
    - 长时间运行, 通常开机开始, 直到系统关闭
    - 后台运行, 没有控制终端
 2. 守护进程的创建:
    - fork
    - setsid
    - fork
    - chdir
    - 关闭不需要的 fd
 3. 守护进程响应信号:
    - SIGTERM: 一般用于守护进程的终止
    - SIGHUP: 一般用来控制守护进程重新读取配置文件
 4. 使用 syslog 记录守护进程的日志:
    - syslog 相关 API
    - syslog 配置文件


** chapter 38 如何写特权安全的程序

** chapter 39 权能

** chapter 40 用户登录记录
 1. 用户登录日志文件:
    - utmp, 记录目前登录到系统的用户, 当用户登录时向该文件写入一条记录, 用户退出
      时, 从该文件中删除登录记录, 命令 who 会使用该文件.
    - wtmp, 记录用户登录和退出的过程, 包括用户名, 登录的终端, 持续时间等, 命令
      last 会使用该文件.
 2. utmpx 相关 API


** chapter 41 共享库基础
1. 解决的问题: 同一份代码被不同的程序所使用, 为了节省硬盘空间和内存空间, 引入了
   共享库技术, 同时可以在共享库中保存调试信息, 这是一个副产品.

2. 静态库: UNIX 系统提供的第一种库, 类似一个目标文件的压缩包, 把公共的代码编译然
   后制作成静态库之后, 以后每个依赖库中代码的目标文件, 就不必重新编译它依赖的那
   部分代码, 只需要链接器进行链接即可, 节省了编译时间. 从目标文件创建静态库可以
   使用 ar 命令.

3. 编译时使用静态库:
   a. 直接在命令行指定静态库全名
   b. 把静态库文件放到链接器 ld 会搜索的某个标准路径中(/usr/lib), 然后使用-l 选项指
      定静态库的名字, 例如-lpthread
   c. 静态库文件不在链接器搜索的标准路径中, 可以通过-L 选项指定附加的搜索路径.

4. 静态库的问题:
   a. 浪费硬盘空间
   b. 浪费内存空间
   c. 修改比较麻烦, 如果静态库中的某个函数功能需要修改, 那么所有依赖这个函数的可
      执行文件如果想得到更新后的功能, 那么就必须要重新编译.

5. 共享库的存在就是为了解决上述问题的, 注意共享库在不同进程之间共享的时代码, 而
   不是数据, 在共享库中定义的全局变量和静态变量在每个进程中都有一份拷贝.

6. 应用程序能够使用共享库的两个条件
   a. 应用程序必须要知道自己要使用哪些共享库
   b. 在运行时, 必须要有一个机制能够在文件系统上找到依赖的共享库, 并且把共享库加
      载到内存中.

7. 共享库的版本号约定:
   a. real name: libNAME.so.major_id.minor_id
   b. soname: libNAME.so.major_id -> libNAME.so.major_id.latest_minor_id, 即
      soname 是某个 major_id 版本的最新 minor_id 的符号链接.
   c. linker name: libNAME.so -> libNAME.so.major_id, 即 linker name 是指向某个
      soname 的符号链接.

      以上三种名字, 构成了一个三层的树形结构, 通过符号链接最终可以找到实际需要的
      共享库文件.

8. 共享库加载规则.

9. 共享库中全局符号的使用规则.
   a. 陷进: 多个共享库之间或者共享库和可执行程序之间若存在同名的全局符号, 包括函
      数以及全局变量, 在静态链接过程中不会报错, 但是在实际运行时调用哪一个函数取
      决于共享库的顺序和全局函数的位置. 这一点不同于.o 文件的链接过程, 若存在同名
      符号会得到重定义错误.

   b. 解决方案:
      - 严格限制符号的可见范围, 比如不想暴露的符号可以使用 static, 使用
        gcc 的__attribute__((visibility("hidden"))), 这种方式是在源码级上进行控制.
      - 编译共享库通过编译参数限定, -Wl,Bsymbolic, 这种是在编译时控制,
        --export-dynamic 暴露主程序的符号给共享库.
      - 动态加载事控制, 通过指定 dlopen 调用时的 flag, RTLD_GLOBAL 这个 flag 可以使得
        当前共享库的符号对后续的共享库可见.


** chapter 42 共享库高级特性
1. 动态加载共享库默认情况下, 可执行程序在启动时, 其所依赖的所有共享库都会被加载.
   但也可以在进程运行过程中, 通过 API 去手动加载某个共享库文件. 比如 dlopen, dlsym,
   dlclose, dlerror. 上述 API 详细说明:
   a. dlopen: 递归加载共享库, 返回一个句柄. 该函数可以多次调用, 每次会返回同一个
      句柄, 但每次调用会使得相应共享库的引用计数加 1, 调用 dlclose 可以使计数减 1,
      当计数减到 0, 共享库会被卸载.
   b. dlsym: 获取库中符号的地址.
   c. dlclose: 关闭一个共享库.
   d. dladdr: 获取给定地址的描述信息.


1. 控制共享库中定义的符号的可见性

2. 在共享库加载或者卸载时执行特定代码使用 gcc 的__attribute__((constructor)),
   __attribute__((destructor))属性定义共享库加载或者卸载时的函数, 函数可以指定多
   个, 名字也可以任意.

4. 共享库预加载

5. 使用 LD_DEBUG 监视动态加载器的行为

** chapter 43 进程间通信概览
1. 进程间通信的范围:
   a. 同一个主机上的进程之间
   b. 不同主机的进程之间, 通过网络进行通信

2. 不同类型的进程通信:
   a. 通信:
      - 数据传递
        + 字节流方式
          - pipe
          - FIFO
          - stream socket
        + 伪终端方式
        + 消息方式
          - 消息队列
          - datagram socket
      - 共享内存

   b. 信号:
      - 常规信号
      - 实时信号

   c. 同步:
      - 信号量
      - 文件锁
      - 互斥量
      - 条件变量

** __插播: 代码整洁之道__

- 什么是整洁的代码呢?
- 命名的整洁之道:
  + 名副其实
  + 不会误导
  + 没有歧义
  + 没有冗余: 类型编码, 匈牙利命名法, 无意义的前缀后缀都是没有必要存在的, 比如一
    个项目就 GRM, 然后项目中每个类都以 GRM 作为前缀命名, 那当你敲出第一个字母 G 之后,
    代码补全工具会返回一个超长的列表, 这纯粹是给自己找麻烦.
- 函数的整洁之道:
  + 每个函数只专注做一件事, 并做好它, 一个函数要么做了一件事情, 要么回答了一个问
    题, 不要让一个函数承担过多的职责.
  + 函数内部应该是下一个抽象层次的函数调用, 直到最后的细节, 这样就可以从高层次的
    抽象开始, 逐步深入到低层次的抽象, 最后看到位于最底层的细节.
  + 不要有大量的重复代码散落在项目之中


** chapter 44 pipe and FIFO

- pipe:
  + 匿名管道, 用于有亲缘关系的进程之间通信.
  + 每次写入的数据不超过 PIPE_BUF, 内核可以保证写入操作的原子性. 如果一次写入的
    数据大于 PIPE_BUF 则不能保证数据的连续性, 即写入的数据有可能和其他进程的写入数
    据交叉.
  + pipe 的容量时有限的, 并且这个容量可以设置.
  + 写入 pipe 的数据不能被重复读取.
  + read pipe: 如果此时管道没有写端, 那么 read 的结果时 end of file, 即读到了文件结
    尾, 得到的数据长度位 0; 如果此时存在写端, 但是写端没有写数据, 那么 read 就会阻
    塞, 直到写端向管道写入了数据.
  + write pipe: 如果写入时管道没有读端, 那么内核会给进程发送信号, 进程可以采用信
    号的默认动作或者自定义的信号处理函数.
- FIFO:
  + 有名管道, 在文件系统中存在对应的文件, 可以用于非亲缘进程之间的通信.
  + 创建 FIFO, mkfifo
  + 创建完成之后, FIFO 可以像普通文件一样进行操作.
  + 打开 FIFO 时需要指定 flag, 说明是读还是写, 以及是否阻塞, 打开 FIFO 时可以阻塞.
- pipe 和 FIFO 的 read/write 语义:
  + read
  + write

** chapter 45 System V IPC 介绍

- System V IPC Objects:
  + message queue:
  + semaphore:
  + shared memory:
- 相关 API:
  + get 类 API: 用于创建 IPC 对象, 或者获取现有的 IPC 对象. IPC 对象有一个 key
    和与之关联的 identifier, 通过这个 identifier 可以使用 IPC 对象. 以 message
    queue 类的 IPC 对象为例, 内核维护了此类对象的一个数据结构, 该数据结构中保存
    一个 seq 和一个 entries, seq 是一个序列号, 每次创建新的 IPC 对象, seq 就会递
    增, entries 是一个数组, 数组的内容时 IPC 对象的指针, IPC 对象中记录了自己的
    key 和创建自己时的 seq, IPC 对象的 identifier 实际上十一个整数, 其计算公式
    为: identifier = index + ipc_object.seq * SOME_CONSTANT, 其中 index 是这个
    IPC 对象在 entries 数组中的下标, 由于每次新建 IPC 对象时, seq 都是递增的, 因
    此, 即使每次创建时使用的时相同的 key, 得到的 identifier 也是不同的, 同时, 通
    过 identifier 可以方便的计算出 index, 这样就可以得到对应的 IPC 对象了, index
    的计算公式如下: index = identifier % SOME_CONSTANT, 这两个公式中
    SOME_CONSTANT 是一个系统常量.
  + ctl 类 API: 可以用来删除 IPC 对象
  + close 类 API:
- System V IPC 的系统资源限制: 每种类型的 IPC 对象都是占用系统资源的, 不可能无限制
  创建, 可以通过 API 调用获取这个资源限制.


** chapter 46 System V Message Queues
- 创建 System V Message Queue:
  + 通过 msgget, 指定 key 和 flag, 创建一个消息队列.
- 发送消息到消息队列:
  + 自己定义一个消息结构体, 包含消息的 type, 消息的数据
  + 调用 msgsnd 进行消息发送, 需要指定消息队列的 identifier, 消息结构体的指针,
    消息结构体的大小等参数.
- 从消息队列接收消息:
  + 调用 msgrcv 进行消息接收, 需要指定消息队列的 identifier, 保存消息的结构体, 消息
    的类型, 根据指定的类型, 内核会采取不同的接收消息策略. 如果 type=0, 那么取队列
    头的第一个消息; 如果 type>0, 那么从队列头开始, 取第一个 type 为指定值的消息; 如
    果 type<0, 那么从队列头开始, 满足消息类型不大于 type 的绝对值, 且类型值最小的消
    息.
- 控制消息队列:
  + msgctl: 可以删除消息队列, 获取消息队列相关的内核数据结构 msqid_ds, 以及其他操
    作.
- System V Message Queue 的不足:
  + 复杂
  + 使用 identifier 作为消息队列的标识, 通过这个句柄操作消息队列, 而不是通过 file
    descriptor
  + System V 消息队列的出现较早, 后续出现的 IPC 方式对其不足做了很大的改进, 所有,
    如过不是必要, 尽量不要使用 System V Message Queue
- 消息队列和管道的比较:
  + 消息队列的通信单位是消息, 而管道是一个字节流.
  + 消息队列取消息可以采用不同的策略, 而管道直到按照流的方式进行读取.

** chapter 47 System V Semaphores
- 信号量的作用:信号量可以看成是一个有内核维护的整数值, 该整数标记了某个资源的数
  量, 并且该资源只能以独占的方式使用. 在一个多进程的环境中, 每个进程都需要使用资
  源, 并且不能被其他进程干扰, 信号量提供了一个进制, 来同步进程之间的动作.
- System V Semaphores:
  + 提供了一个信号量的集合, 对信号量集合的操作是原子的, 这个集合可以看成是进程需
    要的一个资源的集合.
  + 可以对信号量的值进行增加, 减少, 等待为 0 的操作, 并且增加或者减少的数值可以是
    任意的, 而不是被限制为 1.
- System V Semaphores 的使用:
  + semget, 创建一个信号量集合或者获取一个已经存在的信号量集合, 该集合中可以包含
    多个信号量, 从 0 开始计数, 默认情况下, 每个信号量的值都被设置成 0; 得到的信
    号量集合使用一个 identifier 作为句柄.
  + semctl, 设置信号量的值, 获取信号量的值, 获取等待信号量为非 0 值的进程数, 获取
    等待信号量为 0 值的进程数, 获取信号量集合的关联数据结构...
  + semop, 对信号量集合内的信号量进行操作, 这些操作是可以回退的, 为了避免某个进
    程意外终止, 导致其他进程死锁.


** chapter 48 System V Shared Memory
- 概述: 共享内存允许多个进程共享同一块物理内存区域, 不需要内核的介入, 对该区域的
  数据操作其他进程立即可见, 相对其他类型的进程间通信速度比较快. 为了数据的一致性,
  需要在操作共享内存时使用同步手段.
- 使用共享内存的基本方式:
  + shmget: 创建或者获取一块共享内存, 该系统调用返回这块共享内存的 identifier
  + shmat: 将用户空间的一块地址空间和刚刚创建的共享内存区域绑定, 这样进程在访问
    自己地址空间时就等效的访问了贡献内存. 该系统调用返回的指针, 调用进程可以使用,
    根据进程的权限取读取或者写入. 可以指定一个特定的用户地址空间的地址, 也可以让
    内核自己选择一个地址.
  + shmdt: 解除绑定.
  + shmctl: 用于删除共享内存区域, 获取共享内存关联的内核数据结构, 锁定/解锁共享
    内存, 获取共享内存相关的系统限制. 注意, 这里的锁定是指, 使得共享内存所指向的
    物理内存区域常驻内存, 不交换到磁盘上的交换分区, 这样可以提高使用共享内存时的
    性能, 但这种锁定并不保证调用完毕之后整个共享内存的全部页面都已经被锁定, 因为
    可能在调用之前有一部分页面已经被放到了交换分区, 这样只有在下次使用这部分页面
    的时候, 才能将其锁定. 锁定和解锁是设置的内存区域的属性, 而不是进程的属性, 即
    使全部的进程都已经 detach 了该共享内存, 依然需要一个显式的解锁调用, 解除共享
    内存常驻内存的状态.
- 父子进程的共享内存关系:
  + fork 之后, 子进程可以使用父进程的贡献内存.
  + exec 之后, 子进程的共享内存解邦.
- 在共享内存中保存共享内存区域内的指针:
  + 使用相对地址保存, 因为不同共享内存在不同的进程中 attach 到的虚拟内存地址是不
    一定相同的, 对于一个指向共享内存区域内的指针, 如果保存其绝对地址, 那么在其他
    进程中, 有可能就是一个错误的地址, 所以需要使用相对地址进行保存.



** chapter 49 内存映射
- 概述:内存映射可以把一个文件的某个区域映射到进程的地址空间之中, 之后进程对该地
  址的操作就相当于对被映射的文件的操作; 内存映射也可以不映射文件, 而采用匿名的方
  式, 这时进程对应的地址空间会被初始化成 0; 内存映射有 private 和 shared 之分,
  private 类型的内存映射只是用文件来初始化内存的内容, 之后对该区域的操作采用
  copy on write 的方式, 这里需要注意的是父子进程的内存映射的关系; shared 类型的
  内存映射和 private 不同.
- 相关系统调用:
  + mmap:
  + munmap:
  + msync: 同步内存映射中的数据到底层文件或者内核中和文件对应的缓冲区.


** chapter 50 进程虚拟内存操作
- mprot: 改变虚拟内存页面的属性, 读/写/执行
- mlock, mlockall: 锁定虚拟内存的页面, 避免其被交换到 swap 上去. 使用此类 API 有
  两个原因: 1) 为了提高性能; 2) 为了安全, 理论上黑客可以构造出一个消耗大内存的程
  序,使得内核把正常的程序交换到 swap 上, 此时黑客的程序就可以通过直接读取 swap
  的方式获取正常应用的数据.
- mincore: 检查那些页面目前在物理内存的页面上.
- madvise: 通知内核应用程序将如何使用一块虚拟内存区域, 以便内核采取合适的读取或
  者写入策略.

** chapter 51 POSIX IPC 介绍
- 消息队列: 和 System V Message Queue 类似, 进程之间可以通过消息的形式传递数据, 区
  别在于 POSIX 消息队列为消息提供了优先级, 发送到队列的消息按照优先级进行排队.
- 信号量: POSIX 的信号量更简单, 每个信号量单独创建, 而不是创建一个包含多个信号量
  的集合, 并且对信号量的操作只能是加 1 或者减 1, 而不是可以用任意整数进行操作.
- 共享内存:
- POSIX IPC 和 System V IPC 的比较:
  + POSIX IPC 优势:
    - 简单
    - 使用和传统 UNIX 文件一致的 API
    - 使用引用计数, 让应用程序直到什么时候是删除 IPC 对象的正确时机
  + System V IPC 的优势:
    - 可移植性, 几乎所有的 UNIX 类系统都支持, 并且是标准规定的一部分, 不会像 POSIX
      IPC 一样在不同的实现上表现不同.


** chapter 52 POSIX 消息队列
- 概述:
  + 采用引用计数的方式, 一个被标记为删除的消息队列只有在全部使用这个队列的进程都
    关闭了这个队列之后才会被删除.
  + 队列中的消息按照优先级进行排队.
  + 提供了一种异步的通知机制, 当某个消息到来时, 队列可以通知相应的进程.
  + POSIX 消息队列是通过名字进行创建或者获取的, 而不是通过一个 key, 但也只是形式
    不同而一.
  + POSIX 消息队列在 Linux 中是一个可选的模块.
- 使用 POSIX 消息队列相关的 API:
  + mq_open
  + mq_close
  + mq_unlink
  + mq_send: 发送消息到消息队列, 需要指明消息队列描述符, 消息内容, 消息长度, 消
    息的优先级, 消息的优先级数值越大代码优先级越高, 不同的 UNIX 实现, 优先级的取
    值范围是不同的, 这个范围可以通过 sysconf 获取, 最低的优先级是 0, 如果不关心
    优先级可以都设置成 0. 如果此时队列已经满了, 发送动作可以阻塞, 若使用了非阻塞
    方式, 则发送失败, 该系统调用可以发送 0 长度的消息.存在对应的 timeout 版本.
  + mq_receive: 从指定的消息队列中接收消息, 可以选择希望接收消息的优先级, 接收消
    息需要一个消息缓冲区, 这个缓冲区的长度必须大于等于消息队列属性中的消息大小,
    这样才能保证能够接收到完整的消息. 存在对应的 timeout 版本.
  + mq_notify:
    - 在任意一个时刻, 一个消息队列只会有一个进程成功注册通知
    - 只有消息队列从空队列状态接收到了消息才有可能触发发送通知给进程
    - 每次进程收到通知之后, 上册的注册信息会被删除
    - 对于接收到的通知, 进程可以采用信号处理/或者线程的方式进行处理
    - 进程可以手动删除注册数据
  + mq_getattr
  + mq_setattr
- 实现细节:在 Linux 中 POSIX 消息队列的实现实际上使用的是一个虚拟文件系统, 消息队列
  的打开, 关闭, 读取以及写入和对文件的操作类似, 进程在使用 POSIX 消息队列时, 也和
  使用文件类似, 内核会维护三张表, 以实现某种程度的贡献.


** chapter 53 POSIX Semaphores
- 概述:
  + POSIX 信号量有两种, named/unnamed.
  + unamed 信号量没有名字, 其中又可以分为线程共享的信号量以及进程共享的信号量, 其
    中进程共享的信号量可以保存在进程的全局变量中, 进程共享的信号量可以保存在共享
    内存中.
  + unamed 信号量同样可以使用 wait/post/getvalue 操作.
  + POSIX 信号量和 System V 信号量以及线程的 mutex 的比较.

- 使用方法:
  + sem_open
  + sem_close
  + sem_unlink
  + sem_wait
  + sem_post
  + sem_getvalue: 如果此时有多个进程或者线程正在等待减少信号量, 标准规定了该系统
    调用的返回值可以有两种方案, 1) 返回 0; 2) 返回一个负值, 其绝对值代表的是正在
    等待的进程数. 不同的实现会采取不同的方案, Linux 这种情况下返回的是 0.
  + sem_init: 初始化 unamed 信号量.
  + sem_destroy: 销毁 unamed 信号量, 销毁之后可以重新初始化.


** chapter 54 POSIX Shared Memory
- 概述:
  + 和 System V 共享内存相比
  + 和使用文件的内存映射相比
  + 底层使用的是基于内存的文件系统 tmpfs
- 如何使用:
  + shm_open: 创建或者获取一个位于 tmpfs 上的文件描述符, 这个文件描述符可以使用
    传统的文件相关的系统调用进行操作, 比如 ftruncate 改变文件大小
  + mmap: 把上一步得到的文件描述符映射到进程的地址空间
  + 使用上一步得到的映射后的地址
  + munmap:
  + shm_unlink: 删除创建的共享内存对象

** chapter 55 File Lock
- flock: 给整个文件加锁/解锁. 锁的类型包括 shared/exclusive, flock 给文件加锁实际
  上是加在 file description 上的, 所以通过 dup 复制得到的 file descriptor 也具有复制之
  前的锁, fork 之后子进程的 file descriptor 也具有父进程的锁. 可以看出通过三张表,
  锁也是可以共享的.

- fcntl: 可以给文件的一部分加锁/解锁. 该系统调用的参数包括文件描述符, 命令, 以及
  flock 结构体. F_SETLK, F_SETLKW, F_GETLK 这三个命令用于加锁/解锁, 阻塞加锁/解锁,
  获取锁状态. 当使用 F_GETLK 命令时, flock 结构体作为返回结果, 指示当前的锁状态, 即
  文件的对应区域是否存在不兼容的锁, 如果存在, 是那个进程持有该锁(返回的进程是多
  个持有锁的进程中的一个), 其实 F_GETLK 这个命令不太实用, 因为获取完毕之后不能保证
  之后的加锁动作就会成功.

- fcntl 加锁/解锁的语义:
  + 解锁总是会成功, 即使当前进程不持有该文件区域上的锁.
  + 文件的某个特定区域在任意时刻只能存在某种兼容的锁.
  + 可以对一个已经加锁的区域内的某个区域再次加锁或者解锁, 这种情况下该区域内的锁
    会被拆分.

- fcntl 加锁, 锁和进程以及对应文件的 inode 关联. 当进程关闭, 锁全部释放, 当指向同一
  个文件的多个 file descriptor 中的一个 close 了, 锁也会被释放(这是个不合理之处, 有
  历史原因).

- 文件锁的细节:
  + 在 Linux 中多个读锁可能会使得写锁饿死.
  + 当条件满足时, 等待加锁的进程中哪个会成功加锁是不确定的, 和进程调度有关.

- 强制锁:实际上, 上述的锁都不是强制的, 或者说是是 advisory 类型的锁, 即使给一个文
  件区域加了锁, 其他进程还是可以通过 IO 操作读写该区域的内容, 只有其他的进程也按照
  锁相关的 API 进行文件 IO 操作, 锁的语义才会生效; 然而, 文件系统也支持强制锁, 可以
  在挂载文件系统时通过编译选项开启, 或者通过文件的权限组合给某个文件开启强制锁.

- 系统的文件锁记录文件
  + /proc/locks 记录了系统中运行的全部进程加锁情况, 包括锁的类型, 持有锁的进程,
    加锁的文件锁在的设备编号和 inode 号, 文件中加锁的区域.

- 文件锁和单例进程. 可以通过文件锁的方法控制某个程序只有一个进程运行, 比如进程开始
  执行时, 在/var/run 的某个目录下建立一个文件 XXX.pid, 并且尝试给该文件加锁, 如果
  加锁成功, 说明当前进程是第一个, 如果加锁失败, 说明已经有进程在运行相同的程序了,
  当前进程直接退出. 通常进程会在这个文件中记录自己的进程 ID.



** chapter 56 socket 介绍
- 主要内容: 介绍 socket API
- Overview: 典型的 client-server 场景, socket 可以看成是一种"设备", 每个通信的进程
  都需要创建一个这种"设备"; 服务端会把自己的"socket 设备"绑定到一个大家都知道的地
  址上, 这样每个服务端就都可以和服务端通信了.

- Stream Socket:
  1. fd = socket(domain, type, protocol) domain: socket 存在于通信 domain 之中,
     domain 决定了如何标识 socket 以及 socket 通信的范围. type: 指定了 socket 的类
     型, 至少存在两种类型的 socket, 即 SOCK_STREAM 和 SOCK_DGRAM, 前者的特点是面向连
     接, 可靠, 后者的特点是无连接, 不可靠; SOCK_STREAM 类型的 socket 以字节流的形式
     传输数据, SOCK_DGRAM 以数据报的形式传输数据.
  2. bind, 把一个 socket 和一个地址绑定, 通常用于服务端, 绑定的地址是一个众所周知
     的地址, 这样方便客户端进行连接. 也可以采用一个注册中心, 注册中心的地址是所
     有客户端都事先知道的, 服务端上线时将自己的 socket 信息上传到注册中心, 这样客
     户端就可以知道目前可用的服务端了.
  3. listen, 用于服务端, 将 socket 置于 passive 状态, 即被动等待客户端连接的状态, 注
     意客户端可能在服务端刚调用完 listen 就发来请求, 这时服务端的 accept 还没有调用,
     此时的连接称为挂起的连接, 在调用 listen 时可以指定最大的挂起连接数量, 内核根
     据这个最大数量处理挂起的连接.
  4. accept, 接受客户端的请求, 并返回一个 socket 用于和客户端通信, 新返回的 socket
     可以使用 read/write 进行读写, 也可以使用 socket 专用的 API 进行读写操作.
  5. connect, 用于客户端连接服务端.
  6. close, 关闭 socket.

- Datagram Socket:
  1. socket
  2. bind
  3. sendto
  4. recvfrom

- 理解: Stream Socket 类似于打电话, 通信双方之间存在一条连接, 打电话之前需要知道
  对方的号码, 同理, 服务端需要把自己的 socket 绑定到一个客户端知道的地址上;
  Datagram Socket 类似于邮局送信, 通信的双方都有一个信箱, 客户端在请求服务端的时
  候, 必须要知道服务端的信箱地址, 所以同理, 这种情况下, 服务端还是通常还是需要把
  自己的 socket 绑定到一个众所周知的地址, 服务端在收到客户端的请求之后, 如果需要返
  回处理结果给客户端, 只要按照"信封"上的地址回信即可.



- 备注: 在 Linux 中, 上述系统调用实际上是对 socketcall 的封装, 但是在 BSD 以及其他系统
  中不是这样的.



** chapter 57 UNIX domain socket
- 主要内容: 介绍 UNIX domain socket, 用于同一个主机的进程间通信

- 在同一个主机上的进程之间通信, 使用文件系统的路径标识 socket 地址, 文件的权限可以
  限制通信双方对 socket 文件的读写权限.



** chapter 58 TCP/IP 基础
- 主要内容: 介绍计算机网络的基本概念以及 TCP/IP 的关键特性.

- internet: 泛指计算机网络的网络, internet 的目标是使得其上的主机能够通信.

- Internet: 使用 TCP/IP 协议栈的 internet. TCP/IP 起源于 BSD, 很多个实现都派生自
  BSD 的代码, 也有一些是从头实现的(包括 Linux).

- TCP/IP 协议栈结构:
  1. 分层
  2. 下层为上层提供服务
  3. 透明, 对应层之间对等通信
  4. 数据在上下层之间的流动


- 数据链路层

- 网络层:
  - IP 地址结构: 网络号, 主机号, 子网号;
  - 特殊地址: 标记网络, 标记广播, 标记本机
  - 网络层的特点: 尽力而为的传输, 不保证可靠性, 不保证接受端收到数据包的顺序. 网
    络层解决的是主机到主机之间的通信问题.

- 传输层:
  - 解决的问题: 为不同主机或者相同主机上的应用程序提供端到端的通信服务.
  - 两种重要的传输层协议:
    + UDP
      无连接, 不可靠
    + TCP 面向连接, 可靠的传输.

      TCP 提供了"确认, 重传和超时"机制, 并且具有简单的差错校验, 每次发送方发送一
      个数据包之后, 会等待接受方返回一个确认信息, 接收方接受到数据包, 首先会对数
      据容进行校验, 如果是合法的数据包, 则返回一个确认信息给发送方, 否则就丢弃该
      数据包. 发送方在等待一个超时时间之后若还没有收到确认消息就会重新发送该数据
      包.

      TCP 提供了流量控制机制, 为了使得发送速度和接收方的接收速度相匹配, 避免大量
      接收方大量丢包. TCP 两端都维护一个缓冲区, 每次接收方返回 ACK 确认消息时, 会附
      带自己当前的缓冲区剩余大小, 发送方根据这个大小采用滑动窗口算法调整自己的发
      送速度, 从而达到流量控制的目的.

      TCP 提供了拥塞控制机制, 为了使得发送速度和网络的容量相匹配, 因为如果发送发
      发送的速度过快, 导致网路上的路由器处理速度跟不上, 此时路由器只能把来不及处
      理的包丢弃, 这也会导致丢包率过大. 拥塞控制主要有两种考虑, 一是慢启动, 即刚
      开始发送时以一个较低的速度, 之后按照指数提升发送速度; 二是拥塞检测, 当发送
      速度按照指数提升时, 很快发送速度就会达到网络容量的极限, 此时根据丢包情况可
      以检测到发生了拥塞, 可以调整发送速度提升的规律, 不再按照指数增长.


** chapter 59 Internet domain socket
- 主要内容: 介绍 Internet domain socket, 这种 socket 允许不同主机上的医用程序通
  过 TCP/IP 网络进行通信

- 字节序问题: 网络上有很多异构的计算机系统, 使用的字节序不尽相同, 因此在使用网络
  进行通信时, 首先面临的就是字节序的转换问题. TCP/IP 网络使用的时"大端"序, 有些
  计算机系统或者芯片体系架构使用的时"小端"序. 地址由低到高排列, 先存数据的高位称
  为大端序, 反之称为小端序.

- 字节序转换函数:
  htons, htonl, ntohs, ntohl

- 点分 10 进制格式的 IP 地址和网络字节序的整数地址之间的转换 inet_aton,
  inet_addr, ..., inet_pton, inet_ntop, 本质上 IPv4 或者 IPv6 的地址只不过是一个 32 位
  或者 128 位长度的大整数, 以上函数可以完成这个大整数和方便理解的点分 10 进制格式的
  转换.

- DNS:
  - 本地 DNS: /etc/hosts
  - DNS 服务器: 树形结构的分布式系统, 使用缓存避免不必要的解析请求

- /etc/services: 维护了知名的服务所使用的端口和协议, 用户自己的应用不能和这些端口冲突.





** chapter 60 服务端设计
- 主要内容: 讨论使用 socket 进行服务端设计.


** chapter 61 socket 相关的高级主题
- 主要内容: socket IO 的其他特性; TCP 协议的细节; socket 的各种选项.

** chapter 62 终端 Terminals
最初的 UNIX 系统就是一个多用户多任务的系统, 为了实现多用户同时访问系统, 每个用户需
要一个"终端"设备完成输入输出, 最初的 Terminal 有串口和 UNIX 系统连接, 用阴极射线管作
为显示设备, 用 teletypewriter(电传打字机)作为输入设备. 即历史上的确存在这样一个叫
做终端的物理设备.

随着技术的发展, 原来的终端设备已经不能满足新的需求, 比如通过网络登录系统等, 这时
出现了软件形式的终端设备, 即"终端模拟器". 不管是传统的物理终端, 还是现在的终端模
拟器, 都存在一个终端驱动(Terminal Driver)和一个终端设备(Terminal Device), 对于终
端模拟器而言, 这个终端设备就是伪终端(pseudoterminal).

伪终端(pty)包含两个设备, pts(slave 端)和 ptm(master 端), 这两个设备是内核实现的,
在文件系统中可以找到对应的设备文件. pts 和 ptm 构成了一个双向传输数据的通道, 利
用 pty 可以实现远程登录.


* Linux 内核机制以及源码学习

** 问题:
1. 如何本地搭建 linux 内核的开发工程? 可以用 emacs 浏览源码, 编译内核.

2. 如何对内核进行调试?
   a. 使用到的工具:
      - qemu, 提供一个运行待调试内核的平台
      - gdb, 连接运行在 qemu 上的内核进行调试

   b. 整体思路:
      - 首先需要一个编译好的能够调试的内核, 编译这个内核时需要打开必要的配置选项,
        以支持调试
      - 制作一个磁盘镜像, 并在这个镜像上安装编译好的内核, 用于在 qemu 上运行
      - 使用制作好的磁盘镜像启动 qemu
      - 本地启动 gdb 连接 qemu 进行调试

   c. 原理:为了调试内核, 需要编译时设置特殊的编译选项支持; gdb 可以远程调试, qemu
      上运行的内核是调试的对象, 并且相当于一个服务器, 本地的 gdb 连接这个服务器进
      行调试.

3. 准备内核调试过程中遇到的问题
   - initramfs 的作用, 为 init 进程的启动提供必要的支持, initramfs 中包含内核模块,
     命令, 以及一个 init 脚本

   - 如何制作 initramfs?
     内核代码树中提供了脚本, archlinux 中提供了命令, 但具体制作过程还不清楚.

   - 以下几个东西的区别?
     + initramfs
     + ramfs
     + tmpfs
     + rootfs
     + ramdisk
     + initrd

   - 使用 qemu 制作一个虚拟机的 disk image

   - _如何使用 qemu 调试内核???_
     a. 编译好一个带有调试信息的内核;

     b. 制作包含一个根文件系统的文件; 可以手动制作, 也可以使用 buildroot 这个工具;

     c. 使用 qemu 启动编译好的内核; 需要指定合适的参数, -kernel, -hda, -append, -s, -S

     d. 使用 gdb 连接启动的内核, 打断点进行调试;

     *参考文档:* _Prepare the environment for developing Linux kernel with qemu_
     *遗留问题:*
        - 当需要调试某个模块时, 如果修改了模块源码并重新编译, 是否需要重新制作根
          文件系统?

        - 制作根文件系统时哪些东西是必须的? 似乎可以根据需要自己选择.

4. 内核开发涉及到的一些工具?
   - 内核的编译过程, make, Kconfig/Kbuild 的工作原理?

     + 概述: 内核使用 Kconfig 文件管理编译选型, 或者叫配置选项, 这些选项决定了一段
       代码是编译到内核中, 还是编译成内核模块, 或者是不编译这段代码, 有些选项的
       值是一个整数, 代表编译出的内核的一种限制, 比如最大进程数等; Kconfig 文件是
       一种按照 Kconfig 语法写的配置文件, 在内核源码树中形成了一种树形结构, 管理不
       同模块的配置选项;

     + 内核的构建流程:
       1. 使用 make menuconfig 首先构建出 Kbuild, Kbuild 指的是
          /kernel/source/path/scripts/kconfg 下的代码, 这部分代码会在执行
          menuconfig 时首先被编译出来;

       2. 退出 menuconfig 时保存配置选型, 这时会把配置选项写到.config 文件中, 并且
          Kbuild 会使用这个.config 在目录/kernel/source/path/include/generated 以及
          其他目录下生成一些文件, 比如 autoconf.h, 这个文件将配置的编译选项转换成
          了很多宏, 这个文件在编译其他源文件时需要被使用;

       3. 编译 vmlinux 和 modules;

   - 内核的启动原理, initramfs, initrd 等这些东西的作用到底是什么? 是不是启动过程
     必须要使用的? PID 1 这个进程到底是怎么被创建出来的?

   - 内核开发过程中使用到的一些内存检查, 编码规范检查工具, 如何在之后进行内核开
     发时使用?

   - 内核源码树下的脚本的作用?

     1. 一部分是 Kbuild 的源码

     2. 还有一些 perl 脚本, shell 脚本

5. 掌握基础的汇编语言?



** 如何开展之后的学习
暂时不必研究内核的源码, 因为还没有掌握关键的原理, 直接看源码完全是找虐. 那么之后
学习的重点就是内核的原理和机制, 即内核的重要模块到底是如何工作的, 涉及到哪些算法,
在弄清楚原理之后才能开始研究源码. 具体到一个模块的学习可以按照这样的思路, 这个模
块的功能是什么(what), 它是如何实现的(how), 为什么要这样实现(why). 再复杂的问题都
可以通过分而治之的方式解决, 内核也不例外, 所以, 放手干吧.

不应该为了掌握工具而掌握工具, 比如说花大把的时间去学习使用 make, git 等工具, 这类
工具应该在使用中学习, 而不是专门找一个整块的时间去研究这类工具的使用, 了解了基本
的原理之后就练习使用, 在做中学.

之前读到的一本书, 讲整体学习法的. 基本思想是这样, 学习知识的过程就像在头脑中建造
很不城市, 同类的知识在同一个城市中, 不同类的知识在不同的城市中, 理解并掌握知识的
关键在于建立正确的连接, 同一个城市之间的连接以及不同城市之间的连接. 学习的过程包
括获取信息, 理解信息, 建立连接, 纠正连接, 应用知识. 书中还提到了模型的概念, 这里
的模型指的是对知识的一种压缩, 是打开头脑中某个城市的钥匙, 通过这个模型, 可以很快
定位知识. 另一个重要内容是费曼技巧, 个人认为就是用已经有的知识去解释新的知识, 判
断自己是否理解了新的知识, 讲给自己听听就知道了.


** 系统调用
1. syscall 是什么? 内核提供给应用程序的接口, 是内核暴露给上层应用的功能的抽象, 通
   过对 syscall 的组合, 上层应用可以实现各种复杂的功能.

2. 为什么需要 syscall?
   a. 方便上层应用开发. 使之从硬件的细节中脱离出来, syscall 相当于给上层应用提供
      了一台虚拟的计算机, syscall 则是这台虚拟计算机的功能集合.
   b. 安全性. 避免让上层应用直接操作硬件.
   c. 移植性. 上层应用只需要了解自己需要使用到的系统调用, 这样的应用可以方便的移
      植到提供了兼容的 syscall 的系统上去.

3. syscall 和普通函数调用的区别
   a. sycall 涉及到 cpu 态的切换
   b. syscall 需要在用户空间和内核空间之间拷贝数据

4. syscall 的处理过程
   a. 准备 syscall 参数; 包括系统调用号以及其他参数. 在 x86 平台下, 寄存器 eax 用于保
      存 syscall 编号并且接收 syscall 的返回值, 寄存器 ebx, ecx, edx, esi, edi 用于传
      递 syscall 的参数
   b. 触发 syscall; 通过一条特殊的硬件指令, 之后 CPU 切换到内核态运行.
   c. 转到处理 syscall 的总控; 根据 syscall 编号执行对应的处理函数.


** 进程管理
1. 进程在内核中的表示. task_struct 这个结构体维护了进程在内核中的数据, 包括进程
   的标识信息, 进程的状态信息, 进程占有的资源信息, 进程的统计信息等, 相当于进程
   的一个账本. 系统中全部的进程构成一个树形结构, 同时在 task_list 这个双向循环链
   表也维护了系统中的进程数据.

2. 进程的状态
   a. TASK_RUNNING.

   b. TASK_INTERRUPTIBLE. 睡眠状态, 响应信号.

   c. TASK_UNINTERRUPTIBLE. 睡眠状态, 不响应信号.

   d. TASK_TRACED.

   e. TASK_STOPPED.

3. 进程的创建和终止

4. Linux 中的线程


** 进程调度
1. 进程调度的目标: 低延迟, 高吞吐.

2. 进程的分类: IO 密集型, 计算密集型.

3. Linux 调度算法的发展:
   + 原始的调度算法
   + O(1)调度算法, 不适合交互类进程较多的情况, 响应较慢
   + CFS(即 Completely Fair Scheduler), 该算法模拟的是一种理想情况下的多任务 CPU,
     在这个 CPU 上, 进程切换的时间为 0, 每个进程使用 CPU 的时间占 1/N, 其中 N 为
     总的可运行进程数.

4. CFS 详细介绍: 系统设置了一个 target latency 的时间, 这个时间等效于最长的响应
   时间(如果进程切换的时间忽略不计), 每个进程能够使用 CPU 时间的长度比例和总的进
   程数以及自己的 Nice Value 相关, 同时系统设置了一个最短的时间, 防止在进程数太
   多时, 分配到的 CPU 时间趋近于 0.

5. Linux 可以让不同的调度算法共存, 每个调度算法负责一类进程的调度, 不同的调度算法
   之间设置优先级.

6. Real Time 调度. 所谓实时, 是指这类进程响应速度较快, 在 Linux 中实际上时一种 Soft
   Real Time, 没有真正做到实时, 只能保证进程在一个 deadline time 内作出响应.

   a. SCHED_FIFO
      不带时间片, 一旦占有 CPU 就不放, 除非进程阻塞了, 或者明确释放 CPU.

   b. SCHED_RR
      带时间片.

   c. 优先级. 高优先级的进程可以立即抢占低优先级的进程, 实时进程的优先级范围在 0
      到 MAX_RT_PRIO-1 之间.


** emacs 中文输入问题
1. 问题原因.

   在 gui 环境下 emacs 找不到能够使用的字体, 目前看并不是因为 LC_CTYPE 的问题.

2. 解决办法.

   安装 ttf-dejavu 字体包, 具体方式参考 archwiki.



** 中断和中断处理函数
1. 为什么需要中断?

   CPU 和其他硬件设备的速度不匹配, 通过中断机制可以使得 CPU 不必忙等待硬件的操作完
   成, 在硬件工作期间 CPU 可以执行其他任务, 这样可以发挥出系统的整体性能.

2. 中断和异常的区别?

   a. 来源不同; 中断由外部设备产生, 异常是 CPU 在执行指令期间发生的

   b. 中断是异步的; 即何时产生中断通常是不能确定的

3. 中断和异常的相似之处?

   内核在处理这两者的机制上类似, 都是通过某个编号, 找到对应的处理函数开始执行

4. 中断处理函数的注册?

   调用 interrupt_irq(...)函数可以向系统中注册一个中断处理函数(Interrupt Handler
   or Interrupt Service Routine), 函数的参数包括:

   a. 中断号; 用于标识中断.

   b. 中断处理函数; 用户自定义的一个函数, 函数的类型是内核定义好的, 其实现通常在
      驱动程序中.

   c. 标志; 这个 Flag 可以指示内核该中断处理函数执行时是否需要屏蔽其他所有中断; 是
      否将中断产生的时间用于随机数采样; 中断号是否能够共享; ...

   d. void *类型的指针; 用于共享中断号的情况, 对于共享的中断号可能存在多个中断处
      理函数, 这个指针可以看成是一个标识, 通过这个指针可以区分出一个共享中断号的
      不同中断处理函数.

5. 为什么需要把中断的处理分成 Top/Bottom half?

   中断发生时内核应该尽快响应, 在 Top half 中完成必要的工作, 比如, 重置硬件状态,
   拷贝硬件的数据等. 之后应该让硬件继续工作, 这样才能充分发挥硬件的能力, 而其他
   暂时不是必要的工作可以放在 Bottom half 中执行.

6. 注销中断号或者中断处理函数

   free_irq(unsigned int irq, void *dev )


** 中断 Bottom Half

1. 内核实现 Bottom Half 的方式有哪些?

   a. Softirq

      使用这种方式实现 Bottom Half 需要修改内核源码, 灵活性不好.

   b. Tasklet

      基于 Softirq 实现的.

   c. Work Queue

      基于 kernel thread 实现的.

2. process context 和 interrupt context 的区别?

   首先 context 可以理解成环境, 或者说系统当前的状态. process context 指的是进程
   当前所处的环境, 具体包括用户空间 context, 处理器 context, 系统 context, 用户
   空间 context 描述进程的用户空间的代码, 数据, 栈, 堆等内存的情况, 处理器
   context 描述进程相关的寄存器的状态, 系统 context 描述内核维护的进程数据;
   interrupt context 描述中断发生时相关的硬件的状态.




   

** 内核同步机制和方法

1. 为什么需要同步?

   保证数据的一致性.

2. 内核同步机制底层是如何实现的?

   通过特殊的硬件指令实现, 和具体的 CPU 结构有关.

3. 内核提供可哪些同步方法?

   a. 原子操作. 包括对 32 或者 64 位整数的原子操作, 以及位运算的原子操作(这里的位运
      算是指直接设置, 清空, 反转某个位).

   b. 自旋锁

   c. 信号量

   d. 互斥量


** 虚拟文件系统

Virtual File System(VFS), 提供了关于一个文件系统基本的 **抽象**, 比如文件, 目录,
挂载点, 超级块, inode, 目录项等等, 同时这些文件系统的对象都关联了自己对应的操作.
VFS 的存在, **屏蔽** 了不同文件系统之间的差别, 使得应用程序不必关心底层的文件系统
的细节, 比如从文件系统 A 拷贝一个文件到文件系统 B, cp 命令不必理会操作的是两个不
同的文件系统, VFS 这个 **抽象层** 会处理细节. **"软件工程中的任何问题都可以通过
加一个中间层解决"**

1. super_block

   代表文件系统的元数据, 在磁盘上有对应的结构.

2. inode

   代表文件的元数据, 在磁盘上有对应的结构.

3. dentry

   代表路径上的一个目录项目, 在磁盘上没有对应的结构, 在需要时会被创建出来, 同时
   内核维护了一个 dentry 的缓存.

4. file

   代表进程打开的文件, 是文件在内存中的表达. 关联了和文件有关的操作, 记录了文件
   的权限, 读写状态等信息.

5. file_system_type

   代表某个具体的文件系统. 不管系统中挂载了多少个这样的文件系统, 对于一种类型的
   文件系统, 内核只维护一个 file_system_type 实例.

6. vsfmount

   代表文件系统的挂载点, 实际上相当于某个文件系统在内核中的一个实例.

7. files_struct

   记录进程打开的文件. 在进程描述符中有这一项.

8. fs_struct

   记录进程的当前工作目录, 根路径等信息. 在进程描述符中有这一项.

9. mnt_namespace

   让继承能够得知系统中文件系统的概况. 在进程描述符中有这一项. 7, 8, 9 这三个结构
   体都是和进程相关的, 注意在创建子进程时, 是否会继承这些属性.

10. VFS 支持的文件系统类别

    - 基于磁盘

    - 基于网络

    - 特殊文件系统

      可以让系统程序或者系统管理员操作内核的数据结构, 以实现一些特殊的功能. 通过
      文件系统的方式去操作内核的数据结构, 在一定程度上可以复用代码, 同时体现了
      UNIX 中一切皆文件的思想.

11. 根文件系统, root filesystem

    root filesystem 是在系统启动过程中, 由内核直接挂载的, 之后其他的文件系统可以
    挂载到 root fs 之上进行使用, 这样所有的文件系统就组成了一个树形结构, 用户只
    需要了解这个目录树, 而不必关心硬件的细节. 当一个不为空的目录上挂载了一个新的
    文件系统之后, 这个作为挂载点的目录下原来的内容就不可见了, 除非新的文件系统被
    卸载.

12. Namespaces

13. 和文件系统相关的系统调用如何工作?

    - 首先经过 syscall layer, 根据用户传递的系统调用号转到正确的 syscall

    - 然后经过 vfs layer, 调用对应的 vfs_xxx, /比如 vfs_open/

    - 然后经过具体的文件系统层, 比如 ext4, 在系统中注册的文件系统会提供自己的
      operations, 在这一层会调用具体的 fs 提供的操作

    - 根据是否使用缓冲, 接下来会调用缓冲对应的函数, 或者块设备驱动提供的函数

14. **问题??**

    a. vfs layer 是如何找到文件系统对应的 operations 的?

       文件系统注册到内核时, 就已经填充了自己的数据结构.

    b. vfs 基本对象提供的 operations 和 syscall 有什么关系?

       用户空间发起和文件系统相关的系统调用之后, 首先经过 vfs 层, 通过 vfs 层之后再
       调用到实际的文件系统, 之后再往下层调用, 一直到设备驱动层. 这样分层之后,
       通用的逻辑可以集中到某个中间层上, 而不同的中间层具有不同的抽象层次. 在阅
       读代码时也可以采用这种分层的方式, 先搞清楚某一层的内部逻辑, 之后需要再研
       究底层的结构, 不要一开始就迷失在底层的细节中.











* 极客时间--操作系统

** x86架构CPU的工作模式

- 实模式:

  访问内存使用真实的物理地址, 对执行的指令没有权限检查.

  地址总线只有20位, 最大寻址能力只有1M, 寻址时采用"base x 16 + offset"的方式.

  寄存器都是16位.

- 保护模式

  访问内存采用分段和分页的方式, 有特权级的概念, 用来限制能够执行的指令.

  地址总线扩展到32位, 最大寻址能力为4G. 内存中的段使用段描述符进行表示, 需要配置
  一个全局段描述符表, 段描述符中说明了内存段的类型, 特权级, 段基址, 段长度等信息.
  全局段描述符表GDT, 保存在GDTR寄存器中.

- 长模式

  扩展到了64位.

- 汇编语言

  以nasm汇编器为例, 每行汇编代码包含:

  **[label] instrction [operands] [comment]**

  其中label的冒号是可选的. 每个汇编文件包含了text, data, bss等若干段, 汇编代码中
  的instruction有时可以是伪指令, 不对应机器码, 汇编程序和C程序可以相互调用, 在汇
  编中可以直接调用syscall, /global/用来导出汇编程序中的符号, /extern/用来声明外
  部的符号, 可以在汇编程序中调用. 调用syscall或者C函数时需要遵循ABI规范, 即哪些
  寄存器用来传递参数, 返回值如何处理, syscall的编号是什么等.

- **问题:**

  系统的启动过程, 到底都需要干什么? 模式切换的过程? GRUB的multiboot协议具体内容
  是什么? 内核的映像文件要满足什么要求才能被GRUB识别?

** 手工创建vdi硬盘并配置启动项

使用命令创建一个能够被VBox使用的vdi硬盘, 在其中安装grub2, 并且配置一个启动项. 涉
及到的问题有:

- 回环设备

  首先需要通过dd命令创建一个全部被填充为0的文件, 然后通过losetup命令把这个设备转
  换成回环设备, 所谓回环设备是指, 可以将一个文件虚拟成为一个块设备, 这样之前创建
  的文件就可以看成是一个硬盘了, 可以对其进行分区, 并且为分区安装不同的文件系统.

- 安装文件系统

  一个块设备, 或者说硬盘, 必须要安装上一个已经注册进内核的文件系统之后, 才可以挂
  载成功, 然后通过文件系统的方式去使用这个设备.

- UEFI

  和BIOS功能类似的固件程序, 在VBox中创建虚拟机时需要自己进行设置才可以启用UEFI.

- 安装grub2并配置启动项

  实际上是把grub写入到硬盘设备中, 安装时的关键选项包括, --efi-directory,
  --boot-directory, --target, 安装完成之后需要将启动项写到/boot/grub/grub.cfg这
  个配置文件中, 其中set root时hd表示硬盘, 硬盘从0开始编号, gpt2表示采用gpt分区表
  的硬盘的第二个分区, 硬盘分区从1开始编号, 这里具体可以参考grub的官方文档.



** 极客时间之趣谈操作系统

*** 内存管理

1. 内存管理的主要任务
   - 管理物理内存
   - 管理虚拟内存
   - 管理虚拟内存和物理内存之间的映射

2. 物理内存管理
   - 以页为粒度的管理

     伙伴系统. 物理内存被分成大小为11个组, 每组分别包含大小为1, 2, 4, 8, ... ,
     2^10个连续页大小的页块. 当需要分配的内存大小为x页时, 如果x介于(2^(i-1),
     2^i]区间内, 那么从页块大小为2^i的分组开始寻找页块, 如果在该分组内存在空闲的
     页块, 则进行分配, 多余的页向较小的页块组进行转移. 释放内存的过程相反, 需要
     合并页块, 即向较大的也快分组转移.



* x86汇编--从实模式到保护模式

** 实模式

- 访问内存按照分段的方式，通过 __段基址+段内偏移__ 确定实际要访问的物理地址

- 物理内存是对应一个地址空间，这个地址空间上映射的不只有内存条，还有ROM，IO设备等

- 实模式下地址总线只有20位，寻址能力是1M

- 寄存器是16位

- 开机之后CPU的CS和IP寄存器被初始化成了固定的值，这两个寄存器确定的地址刚好落在
  ROM访问内，CPU因而转向ROM执行指令

- ROM中是一段固化的程序，BIOS或者UEFI应该就是在这里了，这段程序的最主要功能是寻
  找启动设备，以硬盘为例，会加载硬盘的MBR扇区到一个固定的地址，CS:IP=0x07C00，理
  论上在MBR扇区上的程序是不需要操作系统就可以加载执行的，可以在这段程序中继续写
  加载OS内核的代码

- 目前接触到的汇编指令

  mov, add, sub, neg, div, idiv, movsb, movsw, cld, std, jxxx, call, ret, retf,
  in, out

- 通过地址总线不仅能够访问内存，也可以访问IO设备的端口，通过读写IO端口就可以实现
  对硬件的控制，比如读写硬盘和显卡


*** TODO [0/3]

**** TODO 了解各种指令的细节

**** TODO 一个包含多个段的程序是如何被加载进内存的? 汇编地址是不是就是虚拟地址? 汇编地址和物理地址有什么关系?

**** TODO 实际写代码完成书中的实验


*** 用户程序加载

x86CPU用分段的方式看待内存, 用户程序在编写时也是分成了若干个段, 编译的结果中默认
是从0开始编址的, 但是实际程序加载的位置是不确定的, 为了保证程序执行的正确性, 需
要重新计算各个段的基地址(段内的偏移是不变的), 这就是程序的重定位. 如果程序是连续
的加载到内存的某个位置, 此时重定位较为简单, 但如果程序中的每个段是分散在内存中的,
重定位就会变得复杂.

*** 中断

中断从来源上看分为 **硬件中断, 内部中断, 软中断**. 其中硬件中断是由外部设备产生
的, 内部中断是因为CPU执行到了非法的指令, 软中断是CPU执行了 **int** 指令触发的.
CPU需要中断控制器和中断打交道, 中断控制器相当于一个中介, 可以通知CPU产生的中断号
是什么, 典型的8952芯片就是一个中断控制器, 两块8952芯片级联之后可以控制15路中断信
号, x86CPU支持最多256个中断.

每个中断都可以配置一个中断处理程序, 在实模式下, 从物理地址0x00000开始, 每个中断
对应一个4字节的项, 用于记录中断处理程序的段基址和段内偏移, 在加载MBR之前, BIOS会
配置这个中断向量表, 表中的项目可以使用一个默认的直接返回程序, 或者使用BIOS提供的
程序, 或者使用相应的硬件的ROM提供的程序(因为内存空间映射的不仅是内存条, 还有其他
硬件, 这些硬件的ROM只要满足一定的格式, 就可以被BIOS扫描并配置到中断向量表之中),
通过查找相关标准可以知道每个BIOS中断对应的是处理什么设备.


* 实际项目

每次学习完一个模块之后通过做对应的项目, 真正做到理论和实践相结合.

** 自己实现一个系统调用
1. 首先需要弄清楚的问题:
   a. 新的 syscall 在哪里声明? 分配 syscall 编号; 指定实现函数; 实现函数的原型声明;
      不同的 arch 这一步似乎是不一样的. x86 平台下, 在 arch 目录下有一个
      syscall_64.tbl 的文件, 记录了 64 位系统的系统调用.
   b. 实现函数在哪里实现? 通常可以在 kernel/sys.c 中实现, 使用 SYSCALL_DEFINEx 这个
      宏. 如果在其他地方实现, 需要修改或者新建 Makefile, 以确保正确编译.
   c. 和新建的 syscall 相关的配置?
   d. 新建的 syscall 如何调用?

** 自己实现一个调度器

** 自己实现一个高级驱动

** 自己实现一个文件系统
