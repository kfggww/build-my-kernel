* Bare Bones I

** 做了什么

1. 构建交叉编译工具链
2. 从汇编文件 boot.s 构建出 boot.o
3. 从 c 文件 kernel.c 构建出 kernel.o
4. 链接以上两个目标文件得到 myos.bin
5. 使用 qemu 加载

** TODO 还有什么问题? [0/3]
   
   - [ ] 交叉编译工具编译出的结果和在宿主机上有什么区别? 所谓的 TARGET 到底代表了什么?
   - [ ] Multiboot 这个标准具体包含什么内容? 目前看 Multiboot 可以看成是
     bootloader 和操作系统之间的一个接口规范, 能够让 bootloader 识别操作
     系统, 以 GRUB 这个 bootloader 为例, 在其配置文件 grub.cfg 中定义了不同
     的内核镜像如何加载. 计算机启动的整体过程应该是"上电 -> BIOS/UEFI
     -> bootloader -> OS", 粗线条的看, 应该是这样的. 这次实验生成的
     boot.o 需要遵循 Multiboot 的要求, 大小, 对齐方式, 特殊的识别标识等.
   - [ ] 需要了解多少 x86 汇编?


* 操作系统设计与实现

** chapter 1 引言

关于微内核和宏内核的比较, 宏内核在效率或者性能上可能会更好一点, 微内核
只在内核中保留必要的部分, 而将其他的功能模块作为用户进程去实现, 造成了
一些额外的进程间通信的开销,因此效率和性能会受到一定影响, 但这样的结构
从理论上更适合构建分布式操作系统, 而且不同功能模块之间的依赖比较弱, 某
个功能模块的崩溃, 不会造成系统的崩溃, 所以两种内核结构各有优势, 需要根
据具体的使用场景进行取舍.

机制和策略分离. 类似于定义了接口, 可以采用不同的实现去完成接口定义的语
义.

** chapter 2 进程

MINIX3 的整体系统结构分为 4 层, 从下至上依次是"内核", "驱动程序", "服务器
"以及"用户进程", 比较特别的一点是, 驱动程序运行在用户态. 


* UNIX 操作系统设计

** chapter1

1. 硬件是按照核心态与用户态看待正在执行的程序的, 而实际运行的是哪个进
   程, 在硬件看来并没有区别; 操作系统按照进程的的角度看待正在执行的程
   序.
2. 内核不是与用户进程平行运行的孤立的进程集合, 而是每个用户进程的一部
   分.

** chapter2
** chapter3

   高速缓冲, 为了提高 IO 效率, 内核会为磁盘上的数据建立一个缓冲区, 使用
哈希表和双向循环链表组织内存中的数据块.

** chapter4

   文件系统的底层算法. 文件系统为了实现对磁盘设备的高效使用, 被设计成
了一种层次化的结构, 最底层是高速缓冲, 提供一种直接对磁盘块读写的服务;
中间一层是文件系统的基础服务, 提供存取 inode, 分配和释放 inode, 分配和释
放磁盘块, 以及从路径到 inode 的解析服务, 中间层的功能依赖下层的高速缓冲;
最上层是文件系统对用户暴露的系统调用层, 提供了更高层次的抽象服务, 文件
读写, 修改权限, 目录操作等相关的系统调用都是这一层提供的.

- inode: 记录了文件的元数据, 包括文件的所有者, 所有组, 修改时间, 权限,
  文件大小, 文件数据的位置信息等等. 应该说 inode 和文件是一一对应的.
- 目录: 目录也是一种文件, 只不过文件的内容记录的是该目录下包含的文件和
  inode 的对应关系.
- 根目录: 内核必须知道文件系统的根目录对应的 inode, 才能实现对文件系统
  内任意一个文件的访问, 因此, 根目录的 inode 必然保存在文件系统的一个特
  定位置, 内核在运行时, 根目录的 inode 会作为一个全局变量, 进程的当前工
  作目录信息由进程自己维护.
- 超级块: 记录了文件系统的全局信息, 包括文件系统有多大, 空闲的磁盘块列
  表, 空闲的 inode 列表, ... , 超级块中的空闲磁盘块列表以及空闲 inode 列表,
  更像是一个在磁盘上的缓存, 这两个列表的数据会随着文件系统的使用动态变
  化, 之所以需要这样的缓存, 是因为不必每次在分配磁盘块或者 inode 的时候
  都要去扫描一遍现有的状态, 需要的时候只要在超级块的缓存中取就好了, 如
  果缓存为空再去进行搜索, 并将超级块的缓存填满.
- 特殊文件: 管道, 设备文件

文件系统的存在, 屏蔽了设备的细节, 用户只要要按照一个统一的树形结构去使
用设备即可, 不必关心数据是在 C 盘还是在 D 盘这种问题.

** chapter5

   主要介绍和文件系统相关的系统调用. 文件主要包括正规文件, 目录, 设备
   文件, 管道等类型. 本章讲述的系统调用有文件的打开, 关闭, 读, 写, 偏
   移, 目录相关, 权限相关, 挂载, 卸载, 复制文件描述符, 建立 link, 释放
   link 等. 管道分为有名和无名, 二者的打开方式不同, 无名管道只能在有亲
   缘关系的进程间使用, 并且会随着进程的声明周期自动销毁, 有名管道在文
   件系统中对应一个特殊的管道文件, 不具有亲缘关系的进程也可以通过有名
   管道进行数据传递, 总之, 管道是一种进程间通信的手段, 在读写管道时也
   涉及到同步和互斥的问题, 无名管道更像是一种共享内存的方式实现的进程
   间通信.

** chapter6

   进程的结构. 内核中存在一个数据结构用于描述进程的全部信息, 包括进程
   的标识信息, 进程的处理机状态信息, 进程的控制信息. 在页式内存管理中,
   _每个进程都有自己的页表_, 页表记录了逻辑页号和物理页号之间的对应关系,
   系统通过页号和页内偏移可以计算出实际要访问的物理地址, CPU 中有一个称
   为快表的结构用来记录若干页表项, 在需要访问内存时, 首先查快表, 如果
   命中则可以根据命中结果访问对应的物理内存地址, 如果未命中, 则需要先
   访问内存中的页表, 经过查找之后得到物理页号, 然后再访问物理内存, 同
   时把新的页表项加入到快表中, 如果快表已经满了, 则要采取某种淘汰策略.
   在实际使用中, 需要对页进行权限保护以及共享, 一个页中可能同时包含两
   种不同类型的数据, 比如同时包含代码和数据, 这时就不方便给页设置权限
   了, 理想的情况是每个页只装载同类型的数据, 这样可以有统一的权限控制,
   为了解决这个问题, 可以采用段页式存储管理, 或者在加载过程中对不足的
   部分填充 0, 比如页面大小式 1KB, 但某个代码段只有 845B 大小, 那么在加载
   时, 页中剩下的部分就可以填充 0, 这样每个段的起始字节总是在页的开始处,
   方便设置页的存取权限.
   

* Operating System 2
** Introduction
ASMP 和 SMP 非对称多处理机. ASMP, kernel 的代码只在一个处理机上执行, 其余
的处理机执行用户代码; SMP, kernel 的代码在每个处理机上都执行, 需要解决
的问题是访问临界区的并发.


* The Linux Documentation Project

** Ext2 文件系统
   为了能够在发生意外崩溃的情况下保证数据的完整性, Ext2 文件系统有一些
   冗余备份的机制, 比如超级块在多个 Block Group 中都存在备份, 同时每个
   Block Group 中的 Group Descripter 也存在备份, 这种方式在意外发生后, 能
   够在一定程度上保证数据的安全.
   虚拟文件系统(VFS)使得 Linux 能够支持不同类型的文件系统.


* 趣谈 Linux

  - 学习 Linux 操作系统的 6 个阶段
    1. 熟练掌握命令行工具
    2. 熟练使用系统调用或者 glibc 实现想要的功能
    3. 掌握理解操作系统原理
    4. 能够阅读并理解 Linux 内核源码
    5. 在理解了内核源码的基础上, 能够对内核进行定制化的修改和扩充, 实现更高级的功能
    6. 在实践中不断理解操作系统, 更深入地学习建立在操作系统基础上的技术


* 操作系统(国防科技大学)

** chapter3 进程与处理机管理
   进程控制块(PCB), 相当于操作系统维护的一个关于进程的账本, 维护了和进
   程相关的必要数据, 包括进程的标识信息, 处理机的状态信息以及进程的控
   制信息.

   进程在执行的过程中, 总是在不同的进程状态之间切换, 直到进程执行完毕
   并退出系统. 从操作系统的角度看到的是进程, 处理机的角度看到的是用户
   态和核心态之间的切换. 当某个进程进入核心态运行时, 逻辑上依然是当前
   的进程在执行.

   进程的调度和进程切换. 引起进程调度的原因, 主要包括两个方面, 首先是
   进程"自己不行了", 1) 进程执行完毕退出; 2) 进程通过系统调用主动放弃
   处理机; 3) 进程在等待 IO, 某个事件, 某个资源, 导致不能在继续执行下去;
   其次是被操作系统剥夺了, 1) 进程的时间片到了; 2) 某个事件发生, 导致
   新就绪的进程出现. 在出现这些原因时, 进程不是马上切换, 进程切换时需
   要保存被切换进程的各种信息, 用于恢复.

   进程调度算法. 为啥需要一种算法专门做调度呢, 就是为了最大化发挥硬件
   的性能, 同时保证用户的响应速度. 多级反馈队列算法, 队列从 1 级到 n 级,每
   个级别内部的进程优先级相同, 优先级递减, 时间片递增, 调度时先从优先
   级的队列开始, 当高优先级队列为空时, 再处理下一个优先级所对应的队列,
   如果某个进程的时间片用完而被剥夺, 那么他的优先级会被降低, 并挂到对
   应的优先级队列中去, 如果某个进程因 IO 请求而让出处理机, 该进程的优先
   级会被调高, 并挂到相应的优先级队列中去. 可以看出从 1 级到 n 级, 进程趋
   向于计算行进程, 从 n 级到 1 级, 进程趋向于 IO 型进程, 这种方式更倾向于 IO
   型进程去调度, 当然这只是理论上的调度算法, 细节还要看具体的实现.

** chapter5 存储管理
   存储管理指的是内存资源的管理, 主要关注进程如何"放"到内存中去, 以及
   在内存空间不足时如何"替换"的问题.

   关于"放", 重点理解非连续存储管理, 进程使用逻辑上连续的地址空间, 但
   实际映射到物理内存时, 其所占用的地址可能是不连续的. 页式内存管理,将
   物理地址空间和逻辑地址空间划分成固定大小的页, 每个进程内部维护一个
   本进程的页表, 记录逻辑页号和物理页号的对应关系, 同时在 CPU 内部通过硬
   件缓存页表的部分页表项, 这个缓存叫做快表, 进程在访问内存地址时通过
   逻辑页号和页内偏移得到实际的物理内存地址, 同时在访存时, 操作系统会
   检查页表项每页的权限, 是否越界等,为了使得同一页的权限相同(读/写/执
   行), 逻辑页在加载到物理页时可以采取填充 0 的方式, 保证每段的起始地址
   也位于页的开始.

   关于"替换", 现代操作系统允许进程的逻辑地址空间大于实际的物理内存,
   进程在运行时只有一部分页面位于物理内存, 而其他部分则在外存中, 这时
   的内存相当于是逻辑地址空间的缓存, 通过这样的方式管理内存成为虚存管
   理. 为了支持虚存, 进程的页表项需要进行改造, 不仅是需要记录逻辑页号
   和物理页号的对应关系, 同时还要记录页表项对应的页是在内存中还是在外
   存中, 页的类型, 页是否被修改了, 如果页修改了, 根据页的类型, 可能需
   要回写到交换分区中去. 影响虚存效率的关键因素是产生缺页异常的频率,
   如果进程在运行时, 频繁的产生缺页异常, 那么操作系统将需要很多时间去
   将外存中的页调入内存, 同时暂时淘汰内存中的某些页, 通常的页淘汰算法
   是 LRU 及其改进, 这个目前只需要了解原理, 具体实现可以之后参考 Linux 源
   码. 虚存面临的另一个问题是, 页表过大, 因为操作系统允许进程的逻辑空
   间现在已经比较大了, 页表中的项自然就多了, 在内存中找一块连续的空间
   保存页表就变得有些困难了, 通常的解决方案是采用多级页表, 但一般就两
   级, 因为页表级别太多会导致访问内存的效率过低.
   

* Linux 设备驱动程序

** chapter9 与硬件通信


* Unix 环境高级编程
  使用类 Unix 系统中的命令时, 各种命令完成的功能几乎都可以通过系统调用的
  方式实现, 并且系统调用的名字通常和命令一样.

  使用 fork 系统调用的两种方式:
  1) 根据返回的 pid 不同, 执行不同的操作, 比如网络服务器, 可能有一个进程
     专门等待请求, 当客户端的请求到来时, 主进程可以新开一个进程去处理
     请求
  2) 根据返回的 pid 不同, 可以选择在子进程中执行 exec 系统调用中的一个, 用
     一个新的程序文件代替刚刚生成的进程中的程序段, 数据段, 并从新的
     main 函数开始执行


* The Linux Programming Interface
  IPC(进程间通信), 是操作系统提供的一种功能, 可以分成 1) 传递数据类, 2)
  进程同步类, 3) 信号. 对于数据传递类, 包括匿名管道, FIFO, 消息队列,
  共享内存, socket 等; 对于进程同步类, 主要包括信号量, 各种锁; 信号, 主
  要用于通知进程某些事件发生了.

  匿名管道(pipe)本质上是一块内核维护的内存空间, 只能用于有亲缘关系的进
  程之间的数据传递(目前看也不绝对, 貌似也可以用于非亲缘关系的进程). 匿
  名管道的几个特点如下:
  - 单向, 数据的传递通常要沿着一个方向
  - 容量有限, 管道的总容量有一个范围, Linux 可以调整, 使用 fcntl
  - 每次写入的数据不超过 PIPE_BUF 时, 写入的操作是原子的, 即一次写入的数
    据不会被打断, 但一次写入的数据超过 PIPE_BUF 限制时, 可能在多进程的情
    况下数据会交织在一起

  FIFO, 有名管道, 在文件系统中存在一个文件和 FIFO 对应, 可以用于非亲缘关
  系的进程传递数据. 涉及到的 syscall 主要包含:
  - 创建 FIFO: mkfifo, 指定 FIFO 的路径名, 以及 mode(权限)
  - 打开: open, 像普通文件一样打开, 指定管道名, 打开方式 oflag 可以决定
    open 是否会阻塞
  - 读: read, 像普通文件一样读
  - 写: write, 像普通文件一样写


** chapter 4
   文件 IO 相关的系统调用. 在类 Unix 系统中, 文件包含常规文件, 设备文件,
   管道文件, 终端等, 这些类型的文件可以用统一的 IO 相关系统调用进行操作.
   主要包含:
   - 文件打开: open
   - 文件关闭: close
   - 文件读取: read
   - 文件写入: write
   - 文件偏移: lseek, 不是所有类型的文件都可以调用, SEEK_SET,
     SEEK_CUR, SEEK_END, 这三个参数在最后, offset 可正可负(除了 SEEK_SET
     之外)
   - IO 控制:   ioctl

   对于常规文件, lseek 可以导致文件中包含空洞, 空洞不占据实际的存储空间,
   但是对于读取文件的进程来说, 读取到文件空洞时, 得到的结果是 0 填充的字
   节序列; 空洞的存在使得文件的名义大小比实际的存储数据的空间大; 向空
   洞内写入不超过空洞大小的数据, 文件的名义大小不发生变化, 但实际存储
   空间必然是变大的.

   并非所有的文件系统都支持文件空洞, 有些文件系统会为填充 0 分配实际的存
   储空间.

   Linux 支持额外两个 whence 参数, 专门针对文件空洞, SEEK_DATA, SEEK_HOLE.

** chapter 5 FILE IO Further Detail
   进一步讲解了 FILE IO 相关内容. 三张表之间的关系, 如何实现的共享和保护.
   其他读写操作, readv/writev, pread/pwrite, preadv/pwitev.
   
** chapter 6 进程
   进程在虚拟地址空间上不同 segment 的分布情况, nolocal goto, 环境变量

** chapter 7 存储空间分配
   系统调用和库函数提供的内存分配功能.

** chapter 8 用户和组
   系统中与用户和组相关的关键文件:
   - /etc/password
   - /etc/group
   - /etc/shadow

   获取上述文件中记录相关的系统调用, 每次获取一条记录/遍历全部记录

** chapter 9 进程身份标识
   - 不同类型的 ID;
   - Linux 特有的 file system UID;
   - 设置和获取不同的 ID

** chapter 10 时间和 Locale
   - 操作系统中时间的类型: 日历时间; 进程时间(用户态, 核心态, 使用 time
     命令可以查看进程的相关时间统计)
   - 时区参数影响时间, 系统在/usr/share/zoneinfo 下的文件中保存了和时区
     设置相关的二进制文件, TZ 环境变量会影响进程对时间相关的系统调用的
     结果, /etc/localtime 文件实际上是一个指向 zoneinfo 下某个文件的符号
     链接
   - Locale 用于处理不同的国家或者民族信息表示方式的差别, 系统在
     /usr/share/locale 下记录了全部相关的 Locale 参数, 每个程序可以有自己
     的 Locale 设置, 可以通过 locale 命令得到当前的 Locale 配置, 不同的配置
     项的作用不同, 有系统调用可以设置 Locale, 或者获取/usr/share/locale
     目录下的某个选项

** chapter 11 系统的限制和选项
   1). Limits. 存在以下几种 limits:
       - 不可变的, 在<limits.h>头文件中已经定义, 运行时也不变
       - 可增加的, 标准中定义了某个 limit 的最小值, 但是具体的系统实现可
         能会比这个值大, 可以通过 sysconf, fpathconf, pathconf 获取
   2). Options. 标准定义了某些特性, 可以通过系统调用得知该系统是否支持
   某个标准定义的特性

   为了代码的可移植性, 在编写代码时需要考虑和系统相关的限制和选项.
   
** chapter 12 系统和进程的信息
   1). 进程信息. 在/proc 目录下记录每个进程自己的数据, 包括进程的状态,
   打开的文件等
   2). 系统信息. 在/proc 目录下也记录和系统相关的信息, 通过 uname 系统调
   用可以得知系统的版本号, 名字等信息

** chapter 13 IO 缓冲

** chapter 14 文件系统
   1). 硬盘
   
   2). 分区

   3). ext2 文件系统的基本结构. 引导块, 超级块, inode 表, 数据区. 超级块
   和 inode 表中的数据是文件系统的元数据, 每个 inode 对应一个文件, inode 中
   记录了文件的各种属性和描述信息, 以及最关键的文件数据保存位置, ext2
   采用 15 个硬盘块指针记录文件数据, 并且分多级, 单个文件的大小足够满足
   目前的需求.

   4). 虚拟文件系统(VFS). Linux 支持不同类型的文件系统, VFS 可以屏蔽不同
   文件系统之间的差异, 给应用程序编程带来方便.

   5). Journaling File System. 类似数据库中的事务, 文件系统会记录其元
   数据的更新, 若系统突然崩溃, 重启之后可以利用这些记录回滚未完成的操
   作, 从而保持文件系统的一致性.

   6). 文件系统的挂载. UNIX 类系统都提供统一的目录树结构, 用户不必在意
   目录下具体的设备信息. 块设备中的文件系统可以挂载到目录下, 之后用户
   直接使用目录就可以使用设备. 挂载的高级特性:
       - 一个文件系统可以挂在到多个目录下, 对其中一个目录下数据的操作
         会反应到其他的目录下
       - 一个目录可以像栈一样挂在文件系统, 后挂载的文件系统可见, 之前
         的被隐藏, 当栈顶的文件系统卸载时, 其下的文件系统又变得可见

    
** chapter 15 文件属性
   文件除了本身包含的数据之外, 还有其他的描述信息, 称为文件属性. 主要
   包含时间戳, 所有权, 权限, 相关的 API 和命令类似.
   
** chapter 16 文件扩展属性
   EAs. 文件的扩展属性, 实际上是文件关联的一组 name-value 对, 其中 name 的
   格式为: namespace.name, namespace 包括 user, trusted, system,
   security. 不同的 namespace 作用不同, 并不是所有的扩展属性用户进程都可
   以访问到. 相关 API:

   设置:
   获取:
   删除:
   遍历:

** chapter 17 Access Control List
   1). 为什么需要 ACL? 为了更精细地控制文件的访问权限, 单纯地将全部的用
   户划分成三类, 然后分别赋予权限, 这种方式在一些情况下不能适用, 比如
   希望单独给某个用户或者某个组设置一种权限.

   2). ACL 本质上是一个列表, 列表中的每项是一个记录, 每个记录是一个三元
   组(tag_type, tag_qualifier, permission), 并且 ACL 列表的记录数量是有
   限制的.

   3). Default ACL. 给目录设置的 ACL 权限, 并且这个 ACL 权限是可以继承的,
   会沿着目录树向下传递.

   4). ACL API. 关键是这组 API 中涉及到的数据结构, 通过调用该组 API 可以实
   现不同数据结构之间的转换. acl_t, acl_entry_t, acl_type_t, void
   *(uid, gid), acl_permset_t.

   5). ACL_MASK 项, 权限的一个上限.

** chapter 18 Directories and Links
   1). 文件夹, 文件, inode 表之间的关系. 文件夹是也是文件, 只是文件夹中
   的内容是一个记录其下包含的文件名和 inode 号之间对应关系的列表; 文件名
   不保存在文件数据块或者 inode 中, 而是保存在文件夹的数据块中; 每个文件
   实际上和一个 inode 对应, inode 中记录了该文件的各种属性以及数据块信息;
   文件系统的根目录在 inode 表中的特殊位置.

   2). Hard Link. 文件夹中记录的表项都是 Hard Link, 多个文件名可以对应
   相同的 inode, 这样就可以实现一个文件有多个名字, 其中的每个 Hard Link
   并没有区别, 从实现的原理看, 就会明白为什么对应的系统调用叫做 link 以
   及 unlink 了.

   3). Symbolic Link. 符号链接或者软链接, 实际上也是一个文件, 只是文件
   的数据中记录了其链接的文件的路径. Symbolic Link 类似 C 语言的指针, 并
   且 Symbolic Link 可以多重, 重数可能受到具体操作系统实现的影响.

   4). 创建目录和删除目录

   5). 遍历某个目录下的内容, opendir, readdir

   6). 遍历目录树. nftw

   7). 和进程相关的有关目录的系统调用. chroot, getcwd, chdir, 其中注意
   chroot jail, "/.." and "/" 之间的关系.

   8). 分别解析路径和文件名. dirname, basename

** chapter 19 监听文件事件
   inotify
   
** chapter 20 信号的基本概念
   - 信号是做什么的?
   - 信号的来源
   - 如何响应信号
   - 如何临时屏蔽信号
   - 如何获取被挂起的信号
   - 如何给其他进程发送信号

**  Doom Emacs 配置
- 是什么? Doom Emacs 是一个 Emacs 的配置框架, 不仅仅是一个配置文件, 有一套自己的工
  具用于更新和诊断等, 同时 Doom Emacs 有自己的配置文件, 可以定义 Emacs 的行为,
  在.doom 目录下, 包含 config.el, init.el 等, 这里用户可以自定义, 比如配置支持的编
  程语言, 修改完配置之后需要按照文件的说明, 确定是否需要执行 doom 命令, 其中 doom
  doctor 可以提供诊断信息, 帮助解决使用过程中的问题.

**  chapter 25 进程的终止
进程终止的类型:
- 异常终止: 接受到了某个信号, 然后终止运行
- 正常终止: 通过系统调用_exit 或者库函数 exit 终止运行

_exit 和 exit 的区别:
- exit 是库函数, 被调用时会检查用户注册的进程终止时的回调函数, 刷新 stdio 的 stream
  所使用的缓冲区, 最后调用_exit 系统调用结束进程的运行
- _exit 是系统调用, 并不会处理回调函数以及标准库使用的缓冲区

注册终止时的回调函数:
- atexit: 标准中定义的
- on_exit: 未在标准中定义, 但是可以给回调函数传递进程终止的状态以及 void*类型的参
  数
回调函数可以注册多个, 同一个回调函数也可以注册多次, 但在 exit 过程中, 多个回调函数
按照注册的逆序被执行; 异常终止的进程不会调用上述库函数注册的回调函数.

** chapter 26 监视子进程
等待子进程终止的系统调用:
- wait, 可以获取子进程终止时的状态以及子进程的 pid, 只要任意一个子进程终止了,
  wait 系统调用就会返回, 若没有子进程则 wait 失败, 返回-1
- waitpid, 可以等待某个特定的子进程终止
  + pid > 0, 等待进程号等于 pid 的子进程终止
  + pid = 0, 等待同一个 group id 的一个子进程终止
  + pid = -1, 等待任意子进程终止
  + pid < -1, 等待子进程 group id 等于 pid 的绝对值的子进程终止, waitpid 可以设
    置选项, 决定是否阻塞等待等.
- 特殊说明: wait/waitpid 系统调用返回的 status 虽然式 int 类型, 但只有低两个字节的内
  容真正被使用
- waitid, 类似 waitpid, 提供了更加精细的控制
- wait3, 等待任意一个子进程终止, 并且返回进程使用的资源
- wait4, 等待一个特定的子进程终止, 并且返回进程使用的资源

孤儿进程和僵尸进程:
- 父进程先终止了, 为了让其子进程仍然具有父进程, 需要让 init 进程领养已经终止的进程
  的全部子进程
- 僵尸进程. 如果在父进程调用 wait 类系统调用之前, 子进程已经终止了, 其占有的内存,
  CPU 等资源已经被内核回收,但为了保证父进程的 wait 调用不受影响, 内核仍然保留已经终
  止的进程的一些统计信息, 包括终止原因, 资源使用情况等, 在父进程调用完 wait 之后,
  僵尸进程也会被清除. _问题:_ 僵尸进程占用的内核资源还会在什么时机被释放?
