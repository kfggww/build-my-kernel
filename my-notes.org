* Bare Bones I

** 做了什么

1. 构建交叉编译工具链
2. 从汇编文件boot.s构建出boot.o
3. 从c文件kernel.c构建出kernel.o
4. 链接以上两个目标文件得到myos.bin
5. 使用qemu加载

** TODO 还有什么问题? [0/3]
   
   - [ ] 交叉编译工具编译出的结果和在宿主机上有什么区别? 所谓的TARGET到底代表了什么?
   - [ ] Multiboot这个标准具体包含什么内容? 目前看Multiboot可以看成是
     bootloader和操作系统之间的一个接口规范, 能够让bootloader识别操作
     系统, 以GRUB这个bootloader为例, 在其配置文件grub.cfg中定义了不同
     的内核镜像如何加载. 计算机启动的整体过程应该是"上电 -> BIOS/UEFI
     -> bootloader -> OS", 粗线条的看, 应该是这样的. 这次实验生成的
     boot.o需要遵循Multiboot的要求, 大小, 对齐方式, 特殊的识别标识等.
   - [ ] 需要了解多少x86汇编?


* 操作系统设计与实现

** chapter 1 引言

关于微内核和宏内核的比较, 宏内核在效率或者性能上可能会更好一点, 微内核
只在内核中保留必要的部分, 而将其他的功能模块作为用户进程去实现, 造成了
一些额外的进程间通信的开销,因此效率和性能会受到一定影响, 但这样的结构
从理论上更适合构建分布式操作系统, 而且不同功能模块之间的依赖比较弱, 某
个功能模块的崩溃, 不会造成系统的崩溃, 所以两种内核结构各有优势, 需要根
据具体的使用场景进行取舍.

机制和策略分离. 类似于定义了接口, 可以采用不同的实现去完成接口定义的语
义.

** chapter 2 进程

MINIX3的整体系统结构分为4层, 从下至上依次是"内核", "驱动程序", "服务器
"以及"用户进程", 比较特别的一点是, 驱动程序运行在用户态. 


* UNIX操作系统设计

** chapter1

1. 硬件是按照核心态与用户态看待正在执行的程序的, 而实际运行的是哪个进
   程, 在硬件看来并没有区别; 操作系统按照进程的的角度看待正在执行的程
   序.
2. 内核不是与用户进程平行运行的孤立的进程集合, 而是每个用户进程的一部
   分.

** chapter2
** chapter3

   高速缓冲, 为了提高IO效率, 内核会为磁盘上的数据建立一个缓冲区, 使用
哈希表和双向循环链表组织内存中的数据块.

** chapter4

   文件系统的底层算法. 文件系统为了实现对磁盘设备的高效使用, 被设计成
了一种层次化的结构, 最底层是高速缓冲, 提供一种直接对磁盘块读写的服务;
中间一层是文件系统的基础服务, 提供存取inode, 分配和释放inode, 分配和释
放磁盘块, 以及从路径到inode的解析服务, 中间层的功能依赖下层的高速缓冲;
最上层是文件系统对用户暴露的系统调用层, 提供了更高层次的抽象服务, 文件
读写, 修改权限, 目录操作等相关的系统调用都是这一层提供的.

- inode: 记录了文件的元数据, 包括文件的所有者, 所有组, 修改时间, 权限,
  文件大小, 文件数据的位置信息等等. 应该说inode和文件是一一对应的.
- 目录: 目录也是一种文件, 只不过文件的内容记录的是该目录下包含的文件和
  inode的对应关系.
- 根目录: 内核必须知道文件系统的根目录对应的inode, 才能实现对文件系统
  内任意一个文件的访问, 因此, 根目录的inode必然保存在文件系统的一个特
  定位置, 内核在运行时, 根目录的inode会作为一个全局变量, 进程的当前工
  作目录信息由进程自己维护.
- 超级块: 记录了文件系统的全局信息, 包括文件系统有多大, 空闲的磁盘块列
  表, 空闲的inode列表, ... , 超级块中的空闲磁盘块列表以及空闲inode列表,
  更像是一个在磁盘上的缓存, 这两个列表的数据会随着文件系统的使用动态变
  化, 之所以需要这样的缓存, 是因为不必每次在分配磁盘块或者inode的时候
  都要去扫描一遍现有的状态, 需要的时候只要在超级块的缓存中取就好了, 如
  果缓存为空再去进行搜索, 并将超级块的缓存填满.
- 特殊文件: 管道, 设备文件

文件系统的存在, 屏蔽了设备的细节, 用户只要要按照一个统一的树形结构去使
用设备即可, 不必关心数据是在C盘还是在D盘这种问题.

** chapter5

   主要介绍和文件系统相关的系统调用. 文件主要包括正规文件, 目录, 设备
   文件, 管道等类型. 本章讲述的系统调用有文件的打开, 关闭, 读, 写, 偏
   移, 目录相关, 权限相关, 挂载, 卸载, 复制文件描述符, 建立link, 释放
   link等. 管道分为有名和无名, 二者的打开方式不同, 无名管道只能在有亲
   缘关系的进程间使用, 并且会随着进程的声明周期自动销毁, 有名管道在文
   件系统中对应一个特殊的管道文件, 不具有亲缘关系的进程也可以通过有名
   管道进行数据传递, 总之, 管道是一种进程间通信的手段, 在读写管道时也
   涉及到同步和互斥的问题, 无名管道更像是一种共享内存的方式实现的进程
   间通信.

** chapter6

   进程的结构. 内核中存在一个数据结构用于描述进程的全部信息, 包括进程
   的标识信息, 进程的处理机状态信息, 进程的控制信息. 在页式内存管理中,
   _每个进程都有自己的页表_, 页表记录了逻辑页号和物理页号之间的对应关系,
   系统通过页号和页内偏移可以计算出实际要访问的物理地址, CPU中有一个称
   为快表的结构用来记录若干页表项, 在需要访问内存时, 首先查快表, 如果
   命中则可以根据命中结果访问对应的物理内存地址, 如果未命中, 则需要先
   访问内存中的页表, 经过查找之后得到物理页号, 然后再访问物理内存, 同
   时把新的页表项加入到快表中, 如果快表已经满了, 则要采取某种淘汰策略.
   在实际使用中, 需要对页进行权限保护以及共享, 一个页中可能同时包含两
   种不同类型的数据, 比如同时包含代码和数据, 这时就不方便给页设置权限
   了, 理想的情况是每个页只装载同类型的数据, 这样可以有统一的权限控制,
   为了解决这个问题, 可以采用段页式存储管理, 或者在加载过程中对不足的
   部分填充0, 比如页面大小式1KB, 但某个代码段只有845B大小, 那么在加载
   时, 页中剩下的部分就可以填充0, 这样每个段的起始字节总是在页的开始处,
   方便设置页的存取权限.
   

* Operating System 2
** Introduction
ASMP和SMP非对称多处理机. ASMP, kernel的代码只在一个处理机上执行, 其余
的处理机执行用户代码; SMP, kernel的代码在每个处理机上都执行, 需要解决
的问题是访问临界区的并发.


* The Linux Documentation Project

** Ext2文件系统
   为了能够在发生意外崩溃的情况下保证数据的完整性, Ext2文件系统有一些
   冗余备份的机制, 比如超级块在多个Block Group中都存在备份, 同时每个
   Block Group中的Group Descripter也存在备份, 这种方式在意外发生后, 能
   够在一定程度上保证数据的安全.
   虚拟文件系统(VFS)使得Linux能够支持不同类型的文件系统.


* 趣谈Linux

  - 学习Linux操作系统的6个阶段
    1. 熟练掌握命令行工具
    2. 熟练使用系统调用或者glibc实现想要的功能
    3. 掌握理解操作系统原理
    4. 能够阅读并理解Linux内核源码
    5. 在理解了内核源码的基础上, 能够对内核进行定制化的修改和扩充, 实现更高级的功能
    6. 在实践中不断理解操作系统, 更深入地学习建立在操作系统基础上的技术


* 操作系统(国防科技大学)

** chapter3 进程与处理机管理
   进程控制块(PCB), 相当于操作系统维护的一个关于进程的账本, 维护了和进
   程相关的必要数据, 包括进程的标识信息, 处理机的状态信息以及进程的控
   制信息.

   进程在执行的过程中, 总是在不同的进程状态之间切换, 直到进程执行完毕
   并退出系统. 从操作系统的角度看到的是进程, 处理机的角度看到的是用户
   态和核心态之间的切换. 当某个进程进入核心态运行时, 逻辑上依然是当前
   的进程在执行.

   进程的调度和进程切换. 引起进程调度的原因, 主要包括两个方面, 首先是
   进程"自己不行了", 1) 进程执行完毕退出; 2) 进程通过系统调用主动放弃
   处理机; 3) 进程在等待IO, 某个事件, 某个资源, 导致不能在继续执行下去;
   其次是被操作系统剥夺了, 1) 进程的时间片到了; 2) 某个事件发生, 导致
   新就绪的进程出现. 在出现这些原因时, 进程不是马上切换, 进程切换时需
   要保存被切换进程的各种信息, 用于恢复.

   进程调度算法. 为啥需要一种算法专门做调度呢, 就是为了最大化发挥硬件
   的性能, 同时保证用户的响应速度. 多级反馈队列算法, 队列从1级到n级,每
   个级别内部的进程优先级相同, 优先级递减, 时间片递增, 调度时先从优先
   级的队列开始, 当高优先级队列为空时, 再处理下一个优先级所对应的队列,
   如果某个进程的时间片用完而被剥夺, 那么他的优先级会被降低, 并挂到对
   应的优先级队列中去, 如果某个进程因IO请求而让出处理机, 该进程的优先
   级会被调高, 并挂到相应的优先级队列中去. 可以看出从1级到n级, 进程趋
   向于计算行进程, 从n级到1级, 进程趋向于IO型进程, 这种方式更倾向于IO
   型进程去调度, 当然这只是理论上的调度算法, 细节还要看具体的实现.

** chapter5 存储管理
   存储管理指的是内存资源的管理, 主要关注进程如何"放"到内存中去, 以及
   在内存空间不足时如何"替换"的问题.

   关于"放", 重点理解非连续存储管理, 进程使用逻辑上连续的地址空间, 但
   实际映射到物理内存时, 其所占用的地址可能是不连续的. 页式内存管理,将
   物理地址空间和逻辑地址空间划分成固定大小的页, 每个进程内部维护一个
   本进程的页表, 记录逻辑页号和物理页号的对应关系, 同时在CPU内部通过硬
   件缓存页表的部分页表项, 这个缓存叫做快表, 进程在访问内存地址时通过
   逻辑页号和页内偏移得到实际的物理内存地址, 同时在访存时, 操作系统会
   检查页表项每页的权限, 是否越界等,为了使得同一页的权限相同(读/写/执
   行), 逻辑页在加载到物理页时可以采取填充0的方式, 保证每段的起始地址
   也位于页的开始.

   关于"替换", 现代操作系统允许进程的逻辑地址空间大于实际的物理内存,
   进程在运行时只有一部分页面位于物理内存, 而其他部分则在外存中, 这时
   的内存相当于是逻辑地址空间的缓存, 通过这样的方式管理内存成为虚存管
   理. 为了支持虚存, 进程的页表项需要进行改造, 不仅是需要记录逻辑页号
   和物理页号的对应关系, 同时还要记录页表项对应的页是在内存中还是在外
   存中, 页的类型, 页是否被修改了, 如果页修改了, 根据页的类型, 可能需
   要回写到交换分区中去. 影响虚存效率的关键因素是产生缺页异常的频率,
   如果进程在运行时, 频繁的产生缺页异常, 那么操作系统将需要很多时间去
   将外存中的页调入内存, 同时暂时淘汰内存中的某些页, 通常的页淘汰算法
   是LRU及其改进, 这个目前只需要了解原理, 具体实现可以之后参考Linux源
   码. 虚存面临的另一个问题是, 页表过大, 因为操作系统允许进程的逻辑空
   间现在已经比较大了, 页表中的项自然就多了, 在内存中找一块连续的空间
   保存页表就变得有些困难了, 通常的解决方案是采用多级页表, 但一般就两
   级, 因为页表级别太多会导致访问内存的效率过低.
   

* Linux设备驱动程序

** chapter9 与硬件通信

* Unix环境高级编程
  使用类Unix系统中的命令时, 各种命令完成的功能几乎都可以通过系统调用的
  方式实现, 并且系统调用的名字通常和命令一样.

  使用fork系统调用的两种方式:
  1) 根据返回的pid不同, 执行不同的操作, 比如网络服务器, 可能有一个进程
     专门等待请求, 当客户端的请求到来时, 主进程可以新开一个进程去处理
     请求
  2) 根据返回的pid不同, 可以选择在子进程中执行exec系统调用中的一个, 用
     一个新的程序文件代替刚刚生成的进程中的程序段, 数据段, 并从新的
     main函数开始执行
