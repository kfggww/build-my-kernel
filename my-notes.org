* Bare Bones I

** 做了什么

1. 构建交叉编译工具链
2. 从汇编文件boot.s构建出boot.o
3. 从c文件kernel.c构建出kernel.o
4. 链接以上两个目标文件得到myos.bin
5. 使用qemu加载

** TODO 还有什么问题? [0/3]
   
   - [ ] 交叉编译工具编译出的结果和在宿主机上有什么区别? 所谓的TARGET到底代表了什么?
   - [ ] Multiboot这个标准具体包含什么内容? 目前看Multiboot可以看成是
     bootloader和操作系统之间的一个接口规范, 能够让bootloader识别操作
     系统, 以GRUB这个bootloader为例, 在其配置文件grub.cfg中定义了不同
     的内核镜像如何加载. 计算机启动的整体过程应该是"上电 -> BIOS/UEFI
     -> bootloader -> OS", 粗线条的看, 应该是这样的. 这次实验生成的
     boot.o需要遵循Multiboot的要求, 大小, 对齐方式, 特殊的识别标识等.
   - [ ] 需要了解多少x86汇编?


* 操作系统设计与实现

** chapter 1 引言

关于微内核和宏内核的比较, 宏内核在效率或者性能上可能会更好一点, 微内核
只在内核中保留必要的部分, 而将其他的功能模块作为用户进程去实现, 造成了
一些额外的进程间通信的开销,因此效率和性能会受到一定影响, 但这样的结构
从理论上更适合构建分布式操作系统, 而且不同功能模块之间的依赖比较弱, 某
个功能模块的崩溃, 不会造成系统的崩溃, 所以两种内核结构各有优势, 需要根
据具体的使用场景进行取舍.

机制和策略分离. 类似于定义了接口, 可以采用不同的实现去完成接口定义的语
义.

** chapter 2 进程

MINIX3的整体系统结构分为4层, 从下至上依次是"内核", "驱动程序", "服务器
"以及"用户进程", 比较特别的一点是, 驱动程序运行在用户态. 

* UNIX操作系统设计

** chapter1

1. 硬件是按照核心态与用户态看待正在执行的程序的, 而实际运行的是哪个进
   程, 在硬件看来并没有区别; 操作系统按照进程的的角度看待正在执行的程
   序.
2. 内核不是与用户进程平行运行的孤立的进程集合, 而是每个用户进程的一部
   分.
* Operating System 2
** Introduction
ASMP和SMP非对称多处理机. ASMP, kernel的代码只在一个处理机上执行, 其余
的处理机执行用户代码; SMP, kernel的代码在每个处理机上都执行, 需要解决
的问题是访问临界区的并发.
